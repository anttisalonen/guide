

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3.3.3. Sudoku Puzzle class &#8212; Learn Programming 0.1</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3.3.4. Finding Sudoku peers" href="sud4.html" />
    <link rel="prev" title="3.3.2. Containers for Sudoku" href="sud2.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sud4.html" title="3.3.4. Finding Sudoku peers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="sud2.html" title="3.3.2. Containers for Sudoku"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Learn Programming 0.1</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch3_index.html" >3. Stage 1.5</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="sud_index.html" accesskey="U">3.3. Learning to program using Sudoku</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.3.3. Sudoku Puzzle class</a><ul>
<li><a class="reference internal" href="#displaying-puzzles">3.3.3.1. Displaying puzzles</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="sud2.html"
                        title="previous chapter">3.3.2. Containers for Sudoku</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sud4.html"
                        title="next chapter">3.3.4. Finding Sudoku peers</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/sud3.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sudoku-puzzle-class">
<h1>3.3.3. Sudoku Puzzle class<a class="headerlink" href="#sudoku-puzzle-class" title="Permalink to this headline">¶</a></h1>
<p>Now, we can start implementing our Puzzle class. From data point of view, this is nothing else but an array of cells. Let’s declare this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Puzzle</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Puzzle</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="nf">solved</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Cell</span><span class="p">,</span> <span class="mi">81</span><span class="o">&gt;</span> <span class="n">cells</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Exercise</em>: Implement the constructor and the “solved” function. The constructor doesn’t need any contents as the array elements will be constructed using the default constructor for Cell, which as per the previous exercise initialises the cell such that all values are possible. The “solved” function will need to check whether all cells have only one number, and only return true in this case. (Initially, it should hence return false.)
Now, we can look into actually constructing an object of class Puzzle by reading a Sudoku puzzle from a file.</p>
<p>As per Norvig, let’s define the file format for a Sudoku puzzle such that a number in a file defines the value for a cell, while either a dot (.) or a zero (0) denote an unknown cell, and all characters can be ignored. This means that e.g. the following line is a valid puzzle (again courtesy Norvig, who sourced the puzzle from Project Euler):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span><span class="mf">3.2</span><span class="o">.</span><span class="mf">6.</span><span class="o">.</span><span class="mf">9.</span><span class="o">.</span><span class="mf">3.5</span><span class="o">..</span><span class="mf">1.</span><span class="o">.</span><span class="mf">18.64</span><span class="o">....</span><span class="mf">81.29</span><span class="o">..</span><span class="mf">7.</span><span class="o">......</span><span class="mf">8.</span><span class="o">.</span><span class="mf">67.82</span><span class="o">....</span><span class="mf">26.95</span><span class="o">..</span><span class="mf">8.</span><span class="o">.</span><span class="mf">2.3</span><span class="o">..</span><span class="mf">9.</span><span class="o">.</span><span class="mf">5.1</span><span class="o">.</span><span class="mf">3.</span><span class="o">.</span>
</pre></div>
</div>
<p>The same puzzle could be represented like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span><span class="mi">3</span> <span class="o">.</span><span class="mf">2.</span> <span class="mf">6.</span><span class="o">.</span>
<span class="mf">9.</span><span class="o">.</span> <span class="mf">3.5</span> <span class="o">..</span><span class="mi">1</span>
<span class="o">..</span><span class="mi">1</span> <span class="mf">8.6</span> <span class="mf">4.</span><span class="o">.</span>

<span class="o">..</span><span class="mi">8</span> <span class="mf">1.2</span> <span class="mf">9.</span><span class="o">.</span>
<span class="mf">7.</span><span class="o">.</span> <span class="o">...</span> <span class="o">..</span><span class="mi">8</span>
<span class="o">..</span><span class="mi">6</span> <span class="mf">7.8</span> <span class="mf">2.</span><span class="o">.</span>

<span class="o">..</span><span class="mi">2</span> <span class="mf">6.9</span> <span class="mf">5.</span><span class="o">.</span>
<span class="mf">8.</span><span class="o">.</span> <span class="mf">2.3</span> <span class="o">..</span><span class="mi">9</span>
<span class="o">..</span><span class="mi">5</span> <span class="o">.</span><span class="mf">1.</span> <span class="mf">3.</span><span class="o">.</span>
</pre></div>
</div>
<p>Now, let’s write the code to read this. In C++, one can read a file to a string with the following snippet (this uses the first parameter given to the program):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">ifs</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">contents</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ifs</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">()));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that we can read file into a string, let’s turn this into a puzzle. First, let’s define the interface:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="n">parse_string</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
     <span class="n">Puzzle</span> <span class="n">b</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In other words, we need the Puzzle class constructor to receive an std::vector&lt;int&gt; as input. Each element in the vector should either be a number between 1 or 9, denoting a pre-filled cell, or something else (like 0) to denote a clear cell. We should also have a function “parse_string” to turn the string to an int vector.</p>
<p>As a skeleton, let’s put something together that also introduces character-to-integer conversions in C++, exceptions and reference parameters.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parse_string</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">buf_location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_buf</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">contents</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;1&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">my_buf</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* TODO */</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buf_location</span> <span class="o">==</span> <span class="mi">81</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* TODO */</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Unable to parse&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Let’s go through this line by line:</p>
<ul class="simple">
<li>Line 1: We define the function such that it takes a parameter “const std::string&amp; s”. A simpler version to write effectively the same thing would be “string s”, however the latter would cause the input string to be copied for the function. With the former version we receive a reference to a constant string instead, saving an unnecessary data copy.</li>
<li>Line 2: We define a variable to keep track of the current cell we might fill.</li>
<li>Line 3: We define our return variable.</li>
<li>Line 4: We iterate over all characters in the string.</li>
<li>Line 5: We check if the character value is between ‘1’ and ‘9’. As the character values are based on the ASCII table, meaning they can be treated as numeric values, we can use arithmetic operators (&gt;= and &lt;=) to compare them.</li>
<li>Line 6: We subtract the ASCII value ‘0’ from “c”. This results in the integer value 0 for the character ‘0’, 1 for character ‘1’, 2 for character ‘2’ etc.</li>
<li>Line 7: We check whether the character is a dot or a zero.</li>
<li>Line 10: We check whether we’ve found a symbol for each cell in the puzzle.</li>
<li>Line 14: If we didn’t find enough symbols of interest, then we cannot fill our array of cells any further and <em>throw an exception</em>: this effectively ends the current execution of the code and goes up the function call stack until a caller is found who <em>catches</em> the exception thrown. As we have no code to catch the exception, this effectively prints the error message on the screen and terminates the program.</li>
</ul>
<p><em>Exercise</em>: Implement the above function. Fill out the correct code for the TODOs such that the return variable is updated correctly and returned. See if you can run it without an exception being thrown with the example input from above.</p>
<p>Now that we’re able to parse a string to an int vector, let’s turn this int vector to a Puzzle.</p>
<p><em>Exercise</em>: Rewrite the constructor of the Puzzle class to take an int vector as a parameter, and loop through it to set the contents of the “cells” member variable. Use the “set” member function of the Cell class to set the values.</p>
<div class="section" id="displaying-puzzles">
<h2>3.3.3.1. Displaying puzzles<a class="headerlink" href="#displaying-puzzles" title="Permalink to this headline">¶</a></h2>
<p>We’re now able to read in a Sudoku puzzle but have no visibility over the contents of the Puzzle class. To remedy this, let’s write a function to display the puzzle. Here’s the declaration:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Puzzle</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="p">...</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>That is, a public member function which doesn’t modify the object.</p>
<p>Now, we can implement this function by looping through the array of cells, and for each cell, print out something. What we print should have the same number of characters for each cell for proper formatting. The simplest way to do this is to either print out a number if a cell has one, or a placeholder (e.g. a space or a dot) otherwise.</p>
<p><em>Exercise</em>: Implement this function and test it.</p>
<p>We can now start thinking about the meat of our program: actually implementing the first strategy of constraint propagation. Recall that what we want to do is:</p>
<ol class="arabic simple">
<li>For each cell that has only a single value set, eliminate that value from all its peers</li>
<li>Since eliminating a value from a cell can cause it to only have a single value set, if this is the case, we should eliminate that value from all its peers</li>
</ol>
<p>In order to implement this, what we need is:</p>
<ol class="arabic simple">
<li>A function to eliminate a value from a cell</li>
<li>Identifying what the peers are for a cell</li>
<li>A function that calls the above functions, i.e. checks, for all cells, which values can be eliminated</li>
</ol>
<p>We already implemented 1) when we implemented the Cell class.</p>
<p>Recall that the peers of a cell are the cells that are on either the same horizontal line, on the same vertical line, or in the same 3x3 sub-grid, i.e. in the same <em>unit</em> as the cell.</p>
<p>When implementing a function for 2), the question arises on what data types should the function use as input and output. It’s often easier to answer this if we consider the user of this function, i.e point 3).</p>
<p>Let’s put this function together in C++:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Puzzle</span><span class="o">::</span><span class="n">propagate</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">has_only_one</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">has_one</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">has_only_one</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_one</span><span class="p">();</span>
         <span class="k">auto</span> <span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">peer</span> <span class="p">:</span> <span class="n">peers</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">if</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="n">peer</span><span class="p">].</span><span class="n">has</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
                 <span class="kt">bool</span> <span class="n">still_valid</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">peer</span><span class="p">].</span><span class="n">eliminate</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                 <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">still_valid</span><span class="p">)</span>
                     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                 <span class="n">still_valid</span> <span class="o">=</span> <span class="n">propagate</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
                 <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">still_valid</span><span class="p">)</span>
                     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
             <span class="p">}</span>
         <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The summary of this function is that we go through each cell, and if it only has one value, we eliminate the value from the peers if they had it. If a peer ends up only having one value, we repeat for that cell. If we invalidate the puzzle with this (which shouldn’t happen), we stop.</p>
<p>Now, a couple of notes:</p>
<ul class="simple">
<li>Line 3: we previously introduced the Cell class member function “has_one”. This is used here.</li>
<li>Line 5: We need an additional function to get the single value (although “get_values” could be used as well).</li>
<li>Line 6: We call the function “peers” which should be a member function of the Puzzle class. This isn’t yet defined. It takes an integer as input (index of a cell in the array “cells”) and returns an array or a vector of indices which are the indices of the peer cells.</li>
<li>Line 7: We iterate through all the peers.</li>
<li>Line 8: We can access the peers in the “cells” array by index “peer”, and call the Cell class member function “has” which should return true if the value is possible for the cell. The function is yet to be defined.</li>
<li>Line 10: We call the function we’re defining for the peer; recursion. What happens is another function call is pushed to the stack, such that we enter the function “propagate” again but with the variable “i” being set to “peer” for this second call. Once that function call returns then we end up at line 10 again, with “i” at the original value, continuing the original for loop to process the rest of the peers. With recursion, it’s important to have a <em>base case</em>, i.e. a case where the recursive call will not be made, to avoid infinite loop. Our base cases are either no cells having only one value, or all peers already having a single value.</li>
</ul>
<p>What we have here, after filling out the blanks, is the propagation function, which eliminates numbers from peer cells, and also propagates this if the peer cell ends up with only one value.</p>
<p><em>Exercise</em>: Implement the “get_one” and “has” member functions for the Cell class.</p>
<p><em>Exercise</em>: What happens when the user of the Cell class calls “get_one” but the cell has more than one value? What is the cell has no values at all (all numbers eliminated)? What would you expect to happen? Is it possible to improve the has_one/get_one interface to avoid invalid use?</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="sud4.html" title="3.3.4. Finding Sudoku peers"
             >next</a> |</li>
        <li class="right" >
          <a href="sud2.html" title="3.3.2. Containers for Sudoku"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Learn Programming 0.1</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch3_index.html" >3. Stage 1.5</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="sud_index.html" >3.3. Learning to program using Sudoku</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Antti Salonen.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>