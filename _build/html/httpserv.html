<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.4. Writing a toy web server &#8212; guide 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7.5. Security" href="sec.html" />
    <link rel="prev" title="7.3. C and strings" href="c_str.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="writing-a-toy-web-server">
<h1>7.4. Writing a toy web server<a class="headerlink" href="#writing-a-toy-web-server" title="Permalink to this headline">¶</a></h1>
<p>After using Flask a bit, you might have wondered &#8220;what&#8217;s actually happening?&#8221;</p>
<p>In essence, Flask receives HTTP requests from the browser over the network, and sends HTML data back to the browser which then displays it. But we should dig a bit further here.</p>
<div class="section" id="osi-model">
<h2>7.4.1. OSI model<a class="headerlink" href="#osi-model" title="Permalink to this headline">¶</a></h2>
<p>The OSI model is a way to structure the network activity in these kinds of situations. There are total seven layers which make up the model:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="23%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Layer</th>
<th class="head">Name</th>
<th class="head">Protocol used in our case</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>7</td>
<td>Application layer</td>
<td>HTTP</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>Presentation layer</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Session layer</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Transport layer</td>
<td>TCP</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Network layer</td>
<td>IP</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Data link layer</td>
<td>Wifi or Ethernet, depending on your network configuration</td>
</tr>
<tr class="row-even"><td>1</td>
<td>Physical layer</td>
<td>E.g. DSL, depending on your network configuration</td>
</tr>
</tbody>
</table>
<p>The layers 1 and 2 are set up depending on your network configuration.</p>
<p>The layers 3 and 4 are implemented by your OS; Windows, Mac and Linux implement the TCP/IP stack in the kernel.</p>
<p>The layers 5, 6 and 7 are all summarised by HTTP. When we ran Flask, we ran its built in HTTP server.</p>
<p>Now, we&#8217;ve used OS functions before: When we open a file in C, we call the open() or fopen() functions, which end up calling kernel functions. The kernel functions typically interact with the actual hardware; In case of opening a file, the kernel functions would read data from the physical hard drive in the computer. Similarly, when writing a HTTP server, &#8220;all&#8221; we need to do is call the relevant kernel functions that trigger TCP/IP communications. Let&#8217;s try this out.</p>
</div>
<div class="section" id="bsd-sockets-api">
<h2>7.4.2. BSD sockets API<a class="headerlink" href="#bsd-sockets-api" title="Permalink to this headline">¶</a></h2>
<p>The API for accessing the TCP/IP stack is called the BSD sockets API. (BSD stands for &#8220;Berkeley Software Distribution&#8221;; the API originates from the University of California, Berkeley.) Here&#8217;s a simple example using it:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">handle_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sa</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sa</span><span class="p">);</span>
	<span class="n">sa</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">sa</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
	<span class="n">sa</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">server_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">server_fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;cannot create socket&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sa</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;bind failed&quot;</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">server_fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen failed&quot;</span><span class="p">);</span>
		<span class="n">close</span><span class="p">(</span><span class="n">server_fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">client_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">&quot;accept failed&quot;</span><span class="p">);</span>
			<span class="n">close</span><span class="p">(</span><span class="n">server_fd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">handle_client</span><span class="p">(</span><span class="n">client_fd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">SHUT_RDWR</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">&quot;shutdown failed&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">close</span><span class="p">(</span><span class="n">client_fd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">close</span><span class="p">(</span><span class="n">server_fd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s walk through this step by step:</p>
<ul class="simple">
<li>Line 14: We define a variable with the type struct sockaddr_in. This is a type that&#8217;s defined as part of the BSD sockets API.</li>
<li>Line 15: We clear all the memory allocated for this variable using the standard C library memset() function.</li>
<li>Lines 16-18: We set some values in that struct, which basically mean that we want to open the TCP/IP port 1234.</li>
<li>Line 20: We use the first function of the BSD sockets API: socket(). This function should return a socket, i.e. something we can use for communications.</li>
<li>Lines 21-24: We check the value of our socket. -1 means something went wrong. In this case we output an error string with perror() and stop the program execution.</li>
<li>Lines 26-36: We use the API to configure our socket such that it listens to incoming connections, i.e. as a server. It listens to TCP port 1234 and will allow up to five connections to line up.</li>
<li>Line 38: We run a for-loop which initialises nothing, has no condition for termination, and does nothing on each iteration. In other words, an infinite loop.</li>
<li>Line 39: We call accept(), another BSD sockets API function. This function call will block, i.e. our program execution will not proceed, until someone connects to the server.</li>
<li>Line 47: We call the function handle_server() which is a function that we will need to write ourselves. This defines what the server actually does.</li>
</ul>
<div class="topic">
<p class="topic-title first">Digression: type casting</p>
<p>Line 26 is also interesting because we perform a <em>type cast</em> here. The line without the type cast would look like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sa</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>That is, we simply pass the address of our struct sockaddr_in to the bind() function. If we were to try this then we would get a compiler warning, turned error if the &#8220;-Werror&#8221; switch is used:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>sock1.c: In <span class="k">function</span> <span class="s1">&#39;main&#39;</span>
sock1.c:26:22: error: passing argument <span class="m">2</span> of <span class="s1">&#39;bind&#39;</span> from incompatible pointer <span class="nb">type</span> <span class="o">[</span>-Werror<span class="o">=</span>incompatible-pointer-types<span class="o">]</span>
  <span class="k">if</span> <span class="o">(</span>bind<span class="o">(</span>server_fd, <span class="p">&amp;</span>sa, sizeof sa<span class="o">)</span> <span class="o">==</span> -1<span class="o">)</span> <span class="o">{</span>
                ^
In file included from sock1.c:2:0:
/usr/include/sys/socket.h:123:12: note: expected <span class="s1">&#39;const struct sockaddr *&#39;</span> but argument is of <span class="nb">type</span> <span class="s1">&#39;struct sockaddr_in *&#39;</span>
 extern int <span class="nb">bind</span> <span class="o">(</span>int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len<span class="o">)</span>
            ^~~~
</pre></div>
</div>
<p>What the error tells us is that the function bind() expects a pointer to <em>struct sockaddr</em> but we pass it a pointer to <em>struct sockaddr_in</em>. Because of the way the API is specified (in the case of IP communication it actually required <em>struct sockaddr_in</em> despite what the function declaration says), we cast the type to <em>struct sockaddr</em>. Type casting basically means telling the compiler &#8220;please pretend this variable has a different type than what it actually has&#8221;. Having this possibility in C makes C a weakly typed language.</p>
</div>
<div class="topic">
<p class="topic-title first">perror?</p>
<p>Most if not all standard C library functions, when they fail, return -1 and set a <em>global</em> variable called &#8220;errno&#8221; (error number). The user is expected to check if the return value is -1 and, if so, the variable errno can be used to obtain more information about the error. What the function perror() does is simply write out a textual description of this variable.</p>
</div>
<p>The code listing above can be compiled e.g. with the following:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ gcc -Wall -Werror -O2 -o sock1 sock1.c <span class="o">&amp;&amp;</span> ./sock1
/tmp/ccf2I2NV.o: In <span class="k">function</span> <span class="sb">`</span>main<span class="s1">&#39;</span>
<span class="s1">sock1.c:(.text.startup+0x73): undefined reference to `handle_client&#39;</span>
collect2: error: ld returned <span class="m">1</span> <span class="nb">exit</span> status
</pre></div>
</div>
<p>Compilation succeeds but linking fails because the function &#8220;handle_client&#8221; isn&#8217;t defined. If we implement that function correctly then we have a simple web server.</p>
<p><em>Exercise</em>: Check out a man page of one of the BSD sockets API, for example by running &#8220;man shutdown&#8221;.</p>
</div>
<div class="section" id="reading-from-a-socket">
<h2>7.4.3. Reading from a socket<a class="headerlink" href="#reading-from-a-socket" title="Permalink to this headline">¶</a></h2>
<p>Here&#8217;s a short and simple implementation of the handle_client function:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">handle_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1023</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This function reads up to 1,023 bytes at once from the client and prints them out to stdout.</p>
<p>Because we now have a server which listens to connections to port 1234, we can try connecting to it using a web browser. We should then see what the web browser sends our program.</p>
<p><em>Exercise</em>: Put together all the above server code and connect to 127.0.0.1:1234 with your browser. 127.0.0.1 means localhost, meaning the computer you&#8217;re running.</p>
</div>
<div class="section" id="http">
<h2>7.4.4. HTTP<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h2>
<p>After doing the above exercise you should see a nice set of text that the web browser has sent our program. On my setup, the first two lines are these:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>GET / HTTP/1.1
Host: <span class="m">127</span>.0.0.1:1234
</pre></div>
</div>
<p>The first line means that the browser would like to retrieve any data from the address / using the HTTP 1.1 protocol. The second line means that from the browser&#8217;s point of view, it&#8217;s connecting to 127.0.0.1:1234.</p>
<p>The full HTTP 1.1 protocol is described in RFCs 7230-7237. RFC&#8217;s (Request for Comments) are documents maintained by W3C (World Wide Web Consortium).</p>
<p><em>Exercise</em>: Look up RFC 7230 online. Don&#8217;t read all of it, but try to get an overview of the HTTP 1.1 architecture.</p>
<p>Now that you&#8217;ve seen RFC 7230, you can probably tell that a simple server response has a few lines of text, beginning with a line such as &#8220;HTTP/1.1 200 OK&#8221;, with the actual data for the user at the end.</p>
</div>
<div class="section" id="refresher-on-c-string-handling">
<h2>7.4.5. Refresher on C string handling<a class="headerlink" href="#refresher-on-c-string-handling" title="Permalink to this headline">¶</a></h2>
<p>Here&#8217;s a snippet that puts some of the C string handling together:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_string</span> <span class="o">=</span> <span class="s">&quot;HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">&quot;</span>
                        <span class="s">&quot;Date: Mon, 27 Jul 2009 12:28:53 GMT</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">my_string</span><span class="p">,</span> <span class="s">&quot;HTTP/1.1&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;my_string begins with </span><span class="se">\&quot;</span><span class="s">HTTP/1.1</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">my_string_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">my_string</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">my_string_len</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">my_string</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;200&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;my_string has the characters </span><span class="se">\&quot;</span><span class="s">200</span><span class="se">\&quot;</span><span class="s"> nine characters after the start.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s see what we have...</p>
<ul class="simple">
<li>Lines 1-2: In C, you can declare strings over multiple lines. The literal quotes will be simply concatenated at compile time. Also note the character sequence rn which means CRLF, or &#8220;carriage return, line feed&#8221;.</li>
<li>Line 4: The function strncmp() checks whether two strings are the same.</li>
<li>Line 8: The function strlen() determines the length of a string.</li>
<li>Line 9: Check that we won&#8217;t be reading past the end of a string to avoid undefined behaviour or creating security holes.</li>
<li>Line 10: By adding a number to a pointer (string), you can effectively start reading from a later point in a string.</li>
<li>Lines 15-18: For turning an integer value to a string (character buffer), allocate a buffer large enough, clear it using memset() and finally use the sprintf() function to write the integer value as the contents of the buffer.</li>
</ul>
<p>With the above knowledge it should be possible to finish the next exercise. You may also find it interesting to take a look at the various man pages of the different functions.</p>
<p><em>Exercise</em>: Modify the function handle_client to check if the client connecting appears to make a HTTP 1.1 GET request. In this case, respond with a valid HTTP 1.1 200 response, replying with a short message such as &#8220;Hello world&#8221;. Make sure you set the Content-Length part of the response correctly. Connect to your server using your web browser to ensure you send the correct data. You can write data to the client by using the write() function, e.g. &#8216;write(fd, &#8220;hello&#8221;, 5);&#8217;. You can also write data piece by piece, by calling write() multiple times.</p>
<p>As you can now see, the browser will be able to render your text, which means you have the beginnings of a web browser. To make things more interesting, let&#8217;s have another exercise.</p>
<p><em>Exercise</em>: Create two HTML pages, with the first one linking to the second. (You can create a link in HTML by using the &lt;a&gt; tag; for example, the following creates a link to a page called two.html: &lt;a href=&#8221;two.html&#8221;&gt;link&lt;/a&gt;.) For the request to /, serve the first HTML page by reading its contents to a buffer and then sending the buffer contents as part of the response. Again, make sure you set the Content-Length part of the response correctly. Parse the request path in detail, such that you&#8217;ll be able to serve the second page when the browser requests it. Note: in order to have the browser display HTML properly, you&#8217;ll need to set the Content-Type field to text/html.</p>
<p>At this stage our implementation doesn&#8217;t respect the whole specification, but it&#8217;s able to serve some web pages. If you made it here, congratulations.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.4. Writing a toy web server</a><ul>
<li><a class="reference internal" href="#osi-model">7.4.1. OSI model</a></li>
<li><a class="reference internal" href="#bsd-sockets-api">7.4.2. BSD sockets API</a></li>
<li><a class="reference internal" href="#reading-from-a-socket">7.4.3. Reading from a socket</a></li>
<li><a class="reference internal" href="#http">7.4.4. HTTP</a></li>
<li><a class="reference internal" href="#refresher-on-c-string-handling">7.4.5. Refresher on C string handling</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="int_c_index.html">7. Intermediate C</a><ul>
      <li>Previous: <a href="c_str.html" title="previous chapter">7.3. C and strings</a></li>
      <li>Next: <a href="sec.html" title="next chapter">7.5. Security</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/httpserv.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Antti Salonen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/httpserv.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>