

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2.4.5. C and strings &#8212; Software Development: A Pragmatic Approach 0.1 documentation</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.4.6. Writing a toy web server" href="httpserv.html" />
    <link rel="prev" title="2.4.4. Dynamic memory allocation" href="c_dyn.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="httpserv.html" title="2.4.6. Writing a toy web server"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="c_dyn.html" title="2.4.4. Dynamic memory allocation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Software Development: A Pragmatic Approach 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch2_index.html" >2. Stage 1</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="int_c_index.html" accesskey="U">2.4. Intermediate C</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.4.5. C and strings</a><ul>
<li><a class="reference internal" href="#c-string-handling">2.4.5.1. C string handling</a></li>
<li><a class="reference internal" href="#pointer-arithmetic-and-substrings">2.4.5.2. Pointer arithmetic and substrings</a></li>
<li><a class="reference internal" href="#digression-debugging">2.4.5.3. Digression: debugging</a></li>
<li><a class="reference internal" href="#string-comparisons">2.4.5.4. String comparisons</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="c_dyn.html"
                        title="previous chapter">2.4.4. Dynamic memory allocation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="httpserv.html"
                        title="next chapter">2.4.6. Writing a toy web server</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/c_str.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="c-and-strings">
<h1>2.4.5. C and strings<a class="headerlink" href="#c-and-strings" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>The most effective debugging tool is still careful thought, coupled with judiciously placed print statements.</p>
<p class="attribution">&mdash;Brian Kernighan</p>
</div></blockquote>
<p>This chapter goes in depth around strings (and buffers in general) in C.</p>
<div class="section" id="c-string-handling">
<h2>2.4.5.1. C string handling<a class="headerlink" href="#c-string-handling" title="Permalink to this headline">¶</a></h2>
<p>Before we continue with C, there are a couple of building blocks regarding string handling that you should know about. Let’s first cover through some basics about strings in C.</p>
<p>C doesn’t really have strings. What it has are buffers (allocation of continuous memory), chars or characters (one byte, representing one ASCII character, meaning English letters, numbers or other symbols) and pointers. Mixing these conceptually results in something like a string. See the below diagram which is a continuous buffer i.e. array with eight slots, each holding one byte (character):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">+-----+-----+-----+-----+-----+------+---+---+</span>
<span class="o">|</span> <span class="sc">&#39;H&#39;</span> <span class="o">|</span> <span class="sc">&#39;e&#39;</span> <span class="o">|</span> <span class="sc">&#39;l&#39;</span> <span class="o">|</span> <span class="sc">&#39;l&#39;</span> <span class="o">|</span> <span class="sc">&#39;o&#39;</span> <span class="o">|</span> <span class="sc">&#39;\0&#39;</span> <span class="o">|</span> <span class="o">?</span> <span class="o">|</span> <span class="o">?</span> <span class="o">|</span>
<span class="o">+-----+-----+-----+-----+-----+------+---+---+</span>
</pre></div>
</div>
<p>This is a buffer with eight slots containing the string “Hello”. The sixth slot is a 0, or ‘\0’, which indicates the end of a string. The value of this is in fact 0 but this has two representations: 0 (the number) or ‘\0’ (character). The last two slots are <em>undefined</em> and reading them results in <em>undefined behaviour</em> like crashing, garbage, nothing, or anything.</p>
<p>You can create such a buffer by e.g. doing the following:</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>Line 1: We allocate the buffer in stack.</li>
<li>Line 2: We write the string “Hello” to the buffer.</li>
</ul>
<p>In general, however, you may write something into a buffer where you don’t know the length of the string in advance. What you’ll need to do in any case is allocate a buffer large enough for your needs, but in addition it’s always best practice to <em>clear</em> the memory in advance, to avoid undefined behaviour. You must also ensure you don’t write <em>past the end</em> of the buffer because this will typically overwrite some of your other variables, probably crashing your program and also possibly creating a security hole. It’s typically better to do this:</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">));</span> <span class="cm">/* sizeof(my_array) will return 8 */</span>
<span class="n">snprintf</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>Line 1: We allocate the buffer in stack.</li>
<li>Line 2: We clear the buffer, such that all the values in the buffer are 0. This way, as long as we keep the last character to 0 in the buffer (remember 0 indicates end of a string), we shouldn’t be either reading or writing past the end of our buffer. (You will need to #include &lt;string.h&gt; to declare memset().)</li>
<li>Line 3: We write the string “Hello” to the buffer using <em>snprintf</em>, which takes as a parameter the maximum number of bytes to write. We tell it to write maximum eight characters such that the last one will always be 0.</li>
</ul>
<p>Now, while array in general is not the same thing as a pointer, for strings the two are sometimes interexchangable. For example, let’s assume you want to pass your array as a parameter to another function. You can’t because arrays are always passed by reference in C. This means that the array will <em>decay</em> into a pointer:</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">my_function</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* sizeof(str) will NOT give an answer as to how long the buffer is */</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">));</span> <span class="cm">/* sizeof(my_array) returns 8 */</span>
    <span class="n">my_function</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Here, “my_function” cannot by itself know how long the string (character buffer) pointed to by “str” is, and must take a second parameter “len” which must have this information. The “sizeof” operator only tells the size of the array (in bytes) at the site where the array is allocated, not where only a pointer is available.</p>
</div>
<div class="section" id="pointer-arithmetic-and-substrings">
<h2>2.4.5.2. Pointer arithmetic and substrings<a class="headerlink" href="#pointer-arithmetic-and-substrings" title="Permalink to this headline">¶</a></h2>
<p>Let’s say we want to modify the array by a character. We can do this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">));</span>
<span class="n">snprintf</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;J&#39;</span><span class="p">;</span> <span class="cm">/* my_array is now &quot;Jello&quot;; */</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;y&#39;</span><span class="p">;</span> <span class="cm">/* my_array is now &quot;Jelly&quot;; */</span>
</pre></div>
</div>
<p>How would we do this if we only had a char pointer, not the array itself? We can use <em>pointer arithmetic</em>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="sc">&#39;J&#39;</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;y&#39;</span><span class="p">;</span>
    <span class="cm">/* or equivalently: str[4] = &#39;y&#39;;         */</span>
    <span class="cm">/* or equivalently: str += 4; *str = &#39;y&#39;; */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_array</span><span class="p">));</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
    <span class="n">my_function</span><span class="p">(</span><span class="n">my_array</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By <em>dereferencing</em> the pointer “str” with * we can access individual characters in the buffer, and also assign to them.</p>
<p>By adding a number n to a pointer the resulting pointer points to data n elements after the first element, and by dereferencing it we can also assign to it.</p>
<p>As a diagram it looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">+-----+-----+-----+-----+-----+------+---+---+</span>
<span class="o">|</span> <span class="sc">&#39;H&#39;</span> <span class="o">|</span> <span class="sc">&#39;e&#39;</span> <span class="o">|</span> <span class="sc">&#39;l&#39;</span> <span class="o">|</span> <span class="sc">&#39;l&#39;</span> <span class="o">|</span> <span class="sc">&#39;o&#39;</span> <span class="o">|</span> <span class="sc">&#39;\0&#39;</span> <span class="o">|</span> <span class="o">?</span> <span class="o">|</span> <span class="o">?</span> <span class="o">|</span>
<span class="o">+-----+-----+-----+-----+-----+------+---+---+</span>
<span class="p">.</span>  <span class="o">^</span>                       <span class="o">^</span>
<span class="p">.</span> <span class="n">str</span>                    <span class="n">str</span> <span class="o">+</span> <span class="mi">4</span>
</pre></div>
</div>
<p>If one were to pass a char pointer to my_function which pointed to less than five bytes of allocated memory, <em>my_function</em> would cause undefined behaviour.</p>
<p>As my_function modifies “str”, the parameter can’t have the const qualifier.</p>
</div>
<div class="section" id="digression-debugging">
<h2>2.4.5.3. Digression: debugging<a class="headerlink" href="#digression-debugging" title="Permalink to this headline">¶</a></h2>
<p>Let’s assume you try to run your program, and it crashes. What’s going on?</p>
<p>There are a few ways to find out. In the worst case, you simply get a segmentation fault, i.e. tried to access memory your program didn’t have access to. There are a few ways to debug this:</p>
<ol class="arabic simple">
<li>Code inspection and hardening - going through the code and adding useful <em>assertions</em> where necessary.</li>
<li>Debug printf - inserting printf calls to various places in your code, seeing which one gets executed, allowing you to pinpoint the line that is the cause for the crash.</li>
<li>Using a <em>debugger</em> to show the root cause of the crash and the state of the program at the time of crash.</li>
</ol>
<p>Assertions seem like going through in more detail. For example, if you have an int variable named “foo”, and you assume it should always be between 0 and 5, you can use this code (after #including &lt;assert.h&gt;):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">foo</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">foo</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, what happens is the program will always check, when executing the statement, whether your statement is true and if not, will immediately crash the program. This is helpful for detecting cases where your assumptions were wrong.</p>
<p>Finally, <em>debuggers</em> are programs which execute your program in a controlled environment with the ability to track and stop the program executiuon when necessary. One potentially useful debugger is <em>gdb</em> (or its clang counterpart, <em>lldb</em>). There are many ways to use it but one way is to get a <em>backtrace</em> of the function calls leading to the crash, i.e. all the function calls in the stack at the time the crash occurred. This can be achieved by following these steps:</p>
<blockquote>
<div><ul class="simple">
<li>Compile the program with “-g3” to get include debug data in the program which will be used by the debugger e.g. to display line numbers</li>
<li>Possibly do not compile with optimisations, i.e. do not compile with “-O2” as this may cause the debugger output to be very different</li>
<li>Instead of running the application with simply “./program abc”, run “gdb –args ./program abc”. This will launch gdb (assuming it’s installed)</li>
<li>gdb will display a prompt, allowing you to enter commands. Simply enter the command “r” (for “run”) and hit enter. This will run the program.</li>
<li>If the program crashes, gdb will let you know and also show the line that caused the crash. With the command “bt” (“backtrace”) you can see the function stack leading up to the call.</li>
<li>You can exit gdb with “q”.</li>
</ul>
</div></blockquote>
<p>Here’s an example gdb session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Reading</span> <span class="n">symbols</span> <span class="kn">from</span> <span class="nn">.</span><span class="o">/</span><span class="n">segv</span><span class="o">...</span><span class="n">done</span><span class="o">.</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">r</span>
<span class="n">Starting</span> <span class="n">program</span><span class="p">:</span> <span class="o">./</span><span class="n">segv</span> <span class="mi">10</span> <span class="mi">10000</span>

<span class="n">Program</span> <span class="n">received</span> <span class="n">signal</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">Segmentation</span> <span class="n">fault</span><span class="o">.</span>
<span class="mh">0x0000000000400825</span> <span class="ow">in</span> <span class="n">run</span> <span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">loop_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span> <span class="n">at</span> <span class="n">segv</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">9</span>
<span class="mi">9</span>           <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">bt</span>
<span class="c1">#0  0x0000000000400825 in run (size=10, loop_size=10000) at segv.c:9</span>
<span class="c1">#1  0x00000000004008c1 in main (argc=3, argv=0x7fffffffe7d8) at segv.c:18</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we can see the program crashed at line segv.c:9, in function “run”, which was entered from function “main” at segv.c:18.</p>
<p>Debuggers can do a lot more, e.g. set breakpoints, display variable names, and more.</p>
<p><em>Exercise</em>: Write a function that will determine the length of a string. You can detect the end of a string by comparing a character in a string against 0, or ‘\0’: if it is 0 then it denotes the end of the string. (This exercise exists for educational purposes; the C standard library includes functions “strlen” and “strnlen” for this.)</p>
<p><em>Exercise</em>: Write a function to count the number of occurrences of the character ‘a’ in a given input string.</p>
<p><em>Exercise</em>: Extend your function from the previous exercise such that the character to count occurrences for is given as an additional input parameter.</p>
</div>
<div class="section" id="string-comparisons">
<h2>2.4.5.4. String comparisons<a class="headerlink" href="#string-comparisons" title="Permalink to this headline">¶</a></h2>
<p>You can check if two strings are the same by using the “strncmp” function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="cm">/* set a and b somehow */</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a and b are the same (at least the first 20 characters).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(You’ll need to #include &lt;string.h&gt; for strncmp as well as most of the other string utility functions, including memset().)</p>
<p>If you want to compare only parts of a string, strncmp can do this too. Let’s say you have a buffer, and you know its first letters are “HTTP/1.1 ” but you want to know whether they are followed by the letters “200”. You can do e.g.:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">input_string</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_string</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;200&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The status code is 200.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What happens here is that we use pointer arithmetic to skip the first nine characters (“HTTP/1.1 “), then compare the next three (and only three) characters with the string “200”. strncmp() returns 0 if the strings matched for the given number of characters.</p>
<p>Another option would be to copy the relevant substring to its own buffer (assuming we don’t want to modify the input string):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">input_string</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* ensure string termination */</span>
<span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">input_string</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;200&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The status code is 200.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function “strncpy” copies n bytes from a source buffer to a destination buffer.</p>
<p>Since it’s only three characters were checking, we could also check them manually:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">input_string</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">input_string</span> <span class="o">+</span> <span class="mi">9</span><span class="p">)</span>  <span class="o">==</span> <span class="sc">&#39;2&#39;</span> <span class="o">&amp;&amp;</span>
   <span class="o">*</span><span class="p">(</span><span class="n">input_string</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span>
   <span class="o">*</span><span class="p">(</span><span class="n">input_string</span> <span class="o">+</span> <span class="mi">11</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The status code is 200.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another potentially useful function is strtok(). Here’s an example of its usage:</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;this is a string.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span> <span class="c1">// p now points to &quot;this&quot;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>      <span class="c1">// p now points to &quot;is&quot;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>      <span class="c1">// p now points to &quot;a&quot;</span>
</pre></div>
</td></tr></table></div>
<p>Finally, the functions “strcat” and “strncat” append a string to an existing string:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="n">strncat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;hello &quot;</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
<span class="n">strncat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">249</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Exercise</em>: Let’s assume you have 50 words with five letters each and you append each word to a buffer using strncat, one after another. (The buffer is assumed to be large enough.) In terms of big O notation, what’s the run time of this algorithm? In order to know where to append to, strncat() iterates through the destination buffer to find the end of the string every time it is called.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="httpserv.html" title="2.4.6. Writing a toy web server"
             >next</a> |</li>
        <li class="right" >
          <a href="c_dyn.html" title="2.4.4. Dynamic memory allocation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Software Development: A Pragmatic Approach 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch2_index.html" >2. Stage 1</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="int_c_index.html" >2.4. Intermediate C</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Antti Salonen.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>