<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1. Basic Unix shell scripting &#8212; guide 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.2. Version control" href="vcs.html" />
    <link rel="prev" title="2. Unix shell" href="unix_index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="basic-unix-shell-scripting">
<h1>2.1. Basic Unix shell scripting<a class="headerlink" href="#basic-unix-shell-scripting" title="Permalink to this headline">Â¶</a></h1>
<p>Basic Unix shell commands are quite useful in day to day software development.</p>
<p>Let&#8217;s assume you have the file with 10,000 lines defining the functions as discussed in &#8220;Generating input data using Python&#8221;. In order to inspect this file, you could open it in the text editor, but there are also other, typically easier, ways to achieve this.</p>
<p>In the following, the character &#8216;$&#8217; means the shell prompt, i.e. you typically type in the shell whatever comes after &#8216;$&#8217;.</p>
<p>If you wanted to take a quick look browsing a file, you could use the utility &#8216;less&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ less test.txt
</pre></div>
</div>
<p>This will open the file test.txt in &#8216;less&#8217;, which allows you to read and browse the file. Less has a few useful commands:</p>
<ul class="simple">
<li>&#8216;q&#8217; exits less</li>
<li>&#8216;/&#8217; allows you to search in the file - type &#8216;/&#8217; followed by the string you want to search for, followed by &#8216;return&#8217;</li>
<li>&#8216;n&#8217; repeats the previous search</li>
<li>&#8216;N&#8217; repeats the previous search but searches backwards</li>
</ul>
<p>There are a few more, and you can look up the reference for &#8216;less&#8217; to see all of them (by running &#8220;man less&#8221;). These same commands are to some degree shared across several other Unix tools. For example vim has the same commands for searching.</p>
<p>Let&#8217;s say you only wanted to see the beginning of the file. You can achieve this using &#8216;head&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ head test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">1</span>.980206 -3.655827 -2.629755
-8.687820 -6.930905 -8.731439
-0.608791 -8.126272 -8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>This will print the first ten lines of the file. You can adjust the number of lines output by using the &#8220;-n&#8221; switch. For example, the command &#8220;head -n5 test.txt&#8221; would only output the first five lines.</p>
<p>The command &#8216;tail&#8217; can be used to output the last lines of a file, by default ten:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ tail test.txt
<span class="o">[</span>...<span class="o">]</span>
-7.058864 -5.461025 -8.337095
-0.197971 -1.485949 -0.748672
-3.051099 -9.215679 <span class="m">3</span>.597125
<span class="m">0</span>.868340 -2.444818 -3.173135
</pre></div>
</div>
<p>If you want to search for a string in the file, you can use &#8216;grep&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ grep <span class="s2">&quot;1234&quot;</span> test.txt
<span class="m">6</span>.133025 -4.612349 <span class="m">4</span>.969612
-0.904910 -5.976920 <span class="m">8</span>.821234
-6.123416 <span class="m">7</span>.494195 <span class="m">4</span>.350390
-1.123468 <span class="m">0</span>.327963 <span class="m">1</span>.291879
</pre></div>
</div>
<p>This command would print all lines which have the string &#8220;1234&#8221; in them. The command &#8216;grep&#8217; also has a lot of useful switches, for example including lines before or after the line that includes the search string, or inverse search (only print lines that don&#8217;t have a match).</p>
<p><em>Exercise</em>: Find out which grep switch makes grep only select non-matching lines.</p>
<p>If you only wanted to print one column of the file, you could achieve this using &#8216;awk&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt
<span class="m">7</span>.269553
<span class="m">1</span>.980206
-8.687820
-0.608791
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>This example only prints the first column in the file. (&#8216;awk&#8217; by default assumed the space is the delimiter character.)</p>
<p>&#8216;awk&#8217; is actually a programming language capable of much more, but much of the daily use is simple one-liners. Let&#8217;s say we want to calculate the average of all values in the first column. This can be achieved using &#8216;awk&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{sum += $1; n++} END {print sum / n}&#39;</span> test.txt
<span class="m">0</span>.0478027
</pre></div>
</div>
<p>What this line means is:</p>
<ul class="simple">
<li>For each line, take the value of the number in the first column, and add it in the variable called &#8220;sum&#8221; (automatically initialised to 0). Increment the variable &#8220;n&#8221; by one (also automatically initialised to 0).</li>
<li>After the file has been processed, print &#8220;sum&#8221; divided by &#8220;n&#8221;, i.e. the sum divided by the number of lines.</li>
</ul>
<p>Another useful command is &#8216;wc&#8217;, or &#8220;word count&#8221;, which can be used to count the words in a file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ wc test.txt
<span class="m">10000</span>  <span class="m">30000</span> <span class="m">284890</span> test.txt
</pre></div>
</div>
<p>The output includes the number of lines, words, characters and the file name. By adding the switch &#8216;-l&#8217;, only the number of lines and the file name are output:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ wc -l test.txt
<span class="m">10000</span> test.txt
</pre></div>
</div>
<p>The final command introduced here is &#8216;sed&#8217;, or &#8220;stream editor&#8221;, which modified the input using a given expression. For example we can use &#8216;sed&#8217; to change all space characters in the file to commas:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sed <span class="s1">&#39;s/ /,/g&#39;</span> test.txt
<span class="m">7</span>.269553,3.427526,6.633603
<span class="m">1</span>.980206,-3.655827,-2.629755
-8.687820,-6.930905,-8.731439
-0.608791,-8.126272,-8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>Let&#8217;s break down this expression &#8216;s/ /,/g&#8217;:</p>
<ul class="simple">
<li>The character &#8216;/&#8217; is the delimiter; the expression consists of four parts: &#8216;s&#8217;, &#8216; &#8216;, &#8216;,&#8217; and &#8216;g&#8217;:</li>
<li>&#8216;s&#8217;: initial command: search (and replace)</li>
<li>&#8216; &#8216;: search for the space character</li>
<li>&#8216;,&#8217;: replace with the comma</li>
<li>&#8216;g&#8217;: do this globally, i.e. not only once per line (the default), but for all occurrences in the file.</li>
</ul>
<p>Another example is removing all &#8216;-&#8216; characters from the file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sed <span class="s1">&#39;s/-//g&#39;</span> test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">1</span>.980206 <span class="m">3</span>.655827 <span class="m">2</span>.629755
<span class="m">8</span>.687820 <span class="m">6</span>.930905 <span class="m">8</span>.731439
<span class="m">0</span>.608791 <span class="m">8</span>.126272 <span class="m">8</span>.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>We can also pass multiple expressions to &#8216;sed&#8217; by using the &#8216;-e&#8217; switch, for example to replace spaces with commas and remove the dashes:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sed -e <span class="s1">&#39;s/ /,/g&#39;</span> -e <span class="s1">&#39;s/-//g&#39;</span> test.txt
<span class="m">7</span>.269553,3.427526,6.633603
<span class="m">1</span>.980206,3.655827,2.629755
<span class="m">8</span>.687820,6.930905,8.731439
<span class="m">0</span>.608791,8.126272,8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<div class="section" id="unix-pipelines">
<h2>2.1.1. Unix pipelines<a class="headerlink" href="#unix-pipelines" title="Permalink to this headline">Â¶</a></h2>
<p>The &#8216;awk&#8217; command above lists the first column for all 10,000 lines which might not be what you want. Let&#8217;s say you only wanted to see the first ten lines, i.e. apply the &#8216;head&#8217; command to the output of the &#8216;awk&#8217; command. You can achieve this using pipelines:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt <span class="p">|</span> head
<span class="m">7</span>.269553
<span class="m">1</span>.980206
-8.687820
-0.608791
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>In this case, head doesn&#8217;t take a file name as input, but instead reads from standard input, i.e. the output from &#8216;awk&#8217;. This is the typical behaviour for Unix commands.</p>
<p>In general, the commands can be combined in any way, giving a lot of power to the user.</p>
<p><em>Exercise</em>: Find out how many lines in the file have no &#8216;0&#8217; character in them.</p>
</div>
<div class="section" id="further-unix-shell-tips-and-tricks">
<h2>2.1.2. Further Unix shell tips and tricks<a class="headerlink" href="#further-unix-shell-tips-and-tricks" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="man">
<h3>2.1.2.1. man<a class="headerlink" href="#man" title="Permalink to this headline">Â¶</a></h3>
<p>The command &#8220;man&#8221; (short for &#8220;manual&#8221;) allows you to browse the documentation of different tools. For example, running &#8220;man grep&#8221; will display the documentation for grep. The documentation is opened using &#8220;less&#8221;, such that you can browse the text freely and exit with &#8216;q&#8217;.</p>
<p>There can be multiple man pages for a single command. For example, &#8220;man signal&#8221; can mean either looking up the signal() C standard library functions or the general overview of signals. The man pages are categorised by type, such that for example category 1 means commands that can be run, 3 means C standard library functions and 7 means miscellaneous documentation. You can specify which category you mean by including it in your command, for example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ man <span class="m">7</span> signal
</pre></div>
</div>
<p>...will look up the man page on signal in category 7, providing the reader with an overview of signals in Unix.</p>
<p><em>Exercise</em>: Look up the man page for the command &#8220;man&#8221;.</p>
<p><em>Exercise</em>: Look up the man page for the C function call &#8220;printf&#8221;.</p>
</div>
<div class="section" id="sort">
<h3>2.1.2.2. sort<a class="headerlink" href="#sort" title="Permalink to this headline">Â¶</a></h3>
<p>The tool &#8220;sort&#8221; sorts its input line by line. By default it sorts alphabetically, but by passing the switch &#8220;-n&#8221; it will interpret its input data numerically. It by default sorts based on the beginning of each line but this can be changed:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sort -n test.txt <span class="p">|</span> head
-9.995596 <span class="m">8</span>.887278 <span class="m">2</span>.325502
-9.995454 -0.339710 <span class="m">4</span>.518171
-9.993047 -9.059912 -0.660508
-9.990530 -5.503126 -8.374026
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>(If your sort command output seems nonsensical, it might be due to the locale set on your shell such that the decimal point is defined as &#8216;,&#8217; instead of &#8216;.&#8217;, confusing sort. You should be able to fix this by running &#8220;export LC_ALL=C&#8221;.)</p>
<p>The above sorted the data based on the first column. If we wanted to sort by the second column instead, we can use:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sort -n -k <span class="m">2</span> test.txt <span class="p">|</span> head
<span class="m">0</span>.649875 -9.998834 <span class="m">2</span>.834749
-3.819303 -9.998413 -7.295722
<span class="m">0</span>.985071 -9.997176 <span class="m">1</span>.182082
-6.991833 -9.995815 -7.523136
</pre></div>
</div>
<p>&#8220;sort&#8221; also allows redefining the delimiter character using the &#8220;-t&#8221; switch. For more information, run &#8220;man sort&#8221;.</p>
</div>
<div class="section" id="variables">
<h3>2.1.2.3. Variables<a class="headerlink" href="#variables" title="Permalink to this headline">Â¶</a></h3>
<p>Variable support is typically something that Unix shells have built in. That is, defining variables isn&#8217;t executing a program per se, but rather using a feature of the shell itself.</p>
<p>Terminology wise, there are different Unix shells (called for example bash, tcsh, zsh), each with different characteristics and quirks, but each one typically implements the same core functionality, namely being compatible with the original Unix shell (sh) and conforming to the POSIX shell specification.</p>
<p>This example defines a variable in bash:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nv">MY_FILE</span><span class="o">=</span>test.txt
$ head -n1 <span class="nv">$MY_FILE</span>
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
</pre></div>
</div>
<p>In other words, defining a variable is trivial, and you can use the variable by prefixing it with a dollar sign.</p>
<p>Sometimes you might want to combine the variable with other bits. In those cases it&#8217;s typically safe to enclose the variable with curly brackets ({ and }). This will make it clear when the variable name starts and ends. For example, if we wanted to combine two variables in one file name:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nv">MY_FILE_START</span><span class="o">=</span><span class="nb">test</span>
$ <span class="nv">MY_FILE_SUFFIX</span><span class="o">=</span>txt
$ <span class="nb">echo</span> <span class="si">${</span><span class="nv">MY_FILE_START</span><span class="si">}</span>.<span class="si">${</span><span class="nv">MY_FILE_SUFFIX</span><span class="si">}</span>
test.txt
</pre></div>
</div>
</div>
<div class="section" id="echo-and-cat">
<h3>2.1.2.4. echo and cat<a class="headerlink" href="#echo-and-cat" title="Permalink to this headline">Â¶</a></h3>
<p>The command &#8220;echo&#8221; simply prints its output. For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s2">&quot;hello&quot;</span>
hello
$ <span class="nb">echo</span> <span class="nv">$MY_FILE</span>
test.txt
</pre></div>
</div>
<p>The command &#8220;cat&#8221; concatenates files. It can also be used to display the contents of a file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cat test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">1</span>.980206 -3.655827 -2.629755
-8.687820 -6.930905 -8.731439
-0.608791 -8.126272 -8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="exit-codes">
<h3>2.1.2.5. Exit codes<a class="headerlink" href="#exit-codes" title="Permalink to this headline">Â¶</a></h3>
<p>Whenever you&#8217;ve finished running a program in Unix, it will return an exit code. The convention is that the exit code 0 means success while non-0 means failure. You can typically see the conditions under which a program returns success or failure by looking at the documentation. For example, grep returns exit code 1 if the search string was not found at all. You can use the special built-in variable $? to access the exit code:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ grep <span class="m">2345</span> test.txt
<span class="m">5</span>.145898 <span class="m">3</span>.219212 <span class="m">3</span>.234599
<span class="m">3</span>.323714 <span class="m">3</span>.883829 -4.722345
<span class="m">6</span>.142345 -4.611688 <span class="m">0</span>.817618
-7.761082 <span class="m">9</span>.886385 -5.742345
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>
$ grep <span class="m">23456</span> test.txt
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-commands">
<h3>2.1.2.6. Multiple commands<a class="headerlink" href="#multiple-commands" title="Permalink to this headline">Â¶</a></h3>
<p>You can run multiple commands in series in one line. The following runs &#8220;head&#8221;, followed by &#8220;tail&#8221;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ head -n <span class="m">1</span> test.txt <span class="p">;</span> tail -n <span class="m">1</span> test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">0</span>.868340 -2.444818 -3.173135
</pre></div>
</div>
<p>You can also run multiple commands depending on the exit code of the previous execution. The shorthand &#8220;&amp;&amp;&#8221; means &#8220;run the following command only if the previous command succeeded, i.e. returned an exit code 0&#8221;. The shorthand &#8220;||&#8221; means &#8220;run the following command only if the previous command failed&#8221;. You can also group commands using parentheses. For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="o">(</span>grep <span class="m">2345</span> test.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span><span class="o">)</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span>
<span class="m">5</span>.145898 <span class="m">3</span>.219212 <span class="m">3</span>.234599
<span class="m">3</span>.323714 <span class="m">3</span>.883829 -4.722345
<span class="m">6</span>.142345 -4.611688 <span class="m">0</span>.817618
-7.761082 <span class="m">9</span>.886385 -5.742345
found
$ <span class="o">(</span>grep <span class="m">23456</span> test.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span><span class="o">)</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span>
not found
</pre></div>
</div>
</div>
<div class="section" id="globbing">
<h3>2.1.2.7. Globbing<a class="headerlink" href="#globbing" title="Permalink to this headline">Â¶</a></h3>
<p>Globbing refers to using special characters to match multiple files. An example is &#8220;*.py&#8221; which means &#8220;all files with the extension .py in the current directory&#8221;. For example, to find out the number of lines in Python files:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ wc -l *.py
 <span class="m">156</span> conf.py
   <span class="m">8</span> gen.py
   <span class="m">4</span> rand.py
   <span class="m">3</span> with.py
 <span class="m">171</span> total
</pre></div>
</div>
</div>
<div class="section" id="seq">
<h3>2.1.2.8. Seq<a class="headerlink" href="#seq" title="Permalink to this headline">Â¶</a></h3>
<p>The command &#8220;seq&#8221; simply outputs a sequence of numbers:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ seq <span class="m">1</span> <span class="m">5</span>
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
</pre></div>
</div>
<p>This might not be very useful by itself but can be handy when combined with other tools.</p>
</div>
<div class="section" id="find">
<h3>2.1.2.9. Find<a class="headerlink" href="#find" title="Permalink to this headline">Â¶</a></h3>
<p>Find is useful for finding files, and optionally performing operations on them.</p>
<p>For example, let&#8217;s assume you have a directory with subdirectories, with the directory and subdirectories having lots of Python files. Let&#8217;s further assume you had used the Python &#8220;with&#8221; statement in some of the files and would like to see how, but you can&#8217;t remember which files exactly use &#8220;with&#8221;. Find and grep to the rescue:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ find . -name <span class="s1">&#39;*.py&#39;</span> -exec grep with <span class="o">{}</span> +
./conf.py:# extensions coming with Sphinx <span class="o">(</span>named <span class="s1">&#39;sphinx.ext.*&#39;</span><span class="o">)</span> or your custom
./with.py:with open<span class="o">(</span><span class="s1">&#39;test.txt&#39;</span>, <span class="s1">&#39;w&#39;</span><span class="o">)</span> as f:
</pre></div>
</div>
<p>Let&#8217;s go through this point by point:</p>
<ul class="simple">
<li>We execute find with several parameters</li>
<li>The first parameter is &#8216;.&#8217;, i.e. search in the current working directory (as well as subdirectories)</li>
<li>Search for files with the extension &#8216;.py&#8217;</li>
<li>For each found file, run &#8220;grep with $filename&#8221;. The notation {} means the found file name will be used here, and the final &#8216;+&#8217; means the grep command will be run for once with all the files as parameters. For example, if the find command found three Python files, ./a.py, subdir/b.py and subdir2/c.py, it would execute &#8220;grep with ./a.py subdir/b.py subdir2/c.py&#8221;.</li>
</ul>
<p>The output has two lines: one with grep matching in conf.py, where a comment using the word &#8220;with&#8221;, and another in with.py where the Python with statement was used.</p>
<p>If we only wanted to find the files with the Python extension without grepping, we simply leave out the -exec part:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ find . -name <span class="s1">&#39;*.py&#39;</span>
./tmp/config.py
./conf.py
./my_project/hello.py
./guess/guess.py
./with.py
./rand.py
</pre></div>
</div>
</div>
</div>
<div class="section" id="redirecting">
<h2>2.1.3. Redirecting<a class="headerlink" href="#redirecting" title="Permalink to this headline">Â¶</a></h2>
<p>You can always write the output of any command to a file by redirecting, i.e. using the &#8216;&gt;&#8217; character:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt &gt; output.txt
</pre></div>
</div>
<p>This will create a file called output.txt, overwriting any previous contents, with the output of the &#8216;awk&#8217; command.</p>
<p>You can also append to the end of an existing file, by using &#8216;&gt;&gt;&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt &gt;&gt; output.txt
</pre></div>
</div>
<p>Redirecting will allow us to simplify writing our own software. For example, it might not be necessary to open a file for writing in Python, so instead of this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
</pre></div>
</div>
<p>...we can simply do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">print</span> <span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p>...and then run it like this:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ python with.py &gt; test.txt
</pre></div>
</div>
<p>This has the added flexibility that we don&#8217;t have to hard code the output file name.</p>
<p>If necessary, you can also discard the output by redirecting it to the special file /dev/null, which has the sole purpose of consuming and discarding all its input:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ python with.py &gt; /dev/null
</pre></div>
</div>
<p><em>Exercise</em>: rewrite your program that generates the 10,000 functions file to write to standard output.</p>
</div>
<div class="section" id="shell-scripts">
<h2>2.1.4. Shell scripts<a class="headerlink" href="#shell-scripts" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="simple-for-loops">
<h3>2.1.4.1. simple for loops<a class="headerlink" href="#simple-for-loops" title="Permalink to this headline">Â¶</a></h3>
<p>In most Unix shells including bash you can define for loops. For example, let&#8217;s say you wanted to run your number generation program three times, and store the output to different files:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="k">for</span> i in <span class="m">1</span> <span class="m">2</span> <span class="m">3</span><span class="p">;</span> <span class="k">do</span> python gen.py &gt; functions_<span class="si">${</span><span class="nv">i</span><span class="si">}</span>.txt <span class="p">;</span> <span class="k">done</span>
</pre></div>
</div>
<p>This will generate three files named functions_1.txt, functions_2.txt and functions_3.txt.</p>
<p>If we wanted to generate a hundred files, typing in the number would get tedious. We can use &#8220;seq&#8221; instead:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> <span class="m">100</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span> python gen.py &gt; functions_<span class="si">${</span><span class="nv">i</span><span class="si">}</span>.txt <span class="p">;</span> <span class="k">done</span>
</pre></div>
</div>
<p>This will generate a hundred files. The notation $(...) allows capturing the output of a command within another command. By using curly braces ({}) around the &#8216;i&#8217; variable we ensure the variable name gets correctly understood by the shell and not confused with the file name template.</p>
</div>
<div class="section" id="if-and-branches">
<h3>2.1.4.2. if and branches<a class="headerlink" href="#if-and-branches" title="Permalink to this headline">Â¶</a></h3>
<p>The shell built-in command &#8220;if&#8221; allows branching. There are other built-ins for comparing values against each other. For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ grep -q <span class="m">2345</span> test.txt <span class="p">;</span> <span class="nv">return_value</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="nv">$return_value</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span><span class="p">;</span> <span class="k">else</span> <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span><span class="p">;</span> <span class="k">fi</span>
</pre></div>
</div>
<p>This command will output &#8220;found&#8221; if the string was found in the input file, and &#8220;not found&#8221; otherwise. (The &#8220;-q&#8221; switch to grep suppresses output.)</p>
</div>
<div class="section" id="storing-scripts-in-a-file">
<h3>2.1.4.3. Storing scripts in a file<a class="headerlink" href="#storing-scripts-in-a-file" title="Permalink to this headline">Â¶</a></h3>
<p>It&#8217;s often practical to store scripts to a file. Here&#8217;s the previous example stored in a file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

grep -q <span class="m">2345</span> test.txt
<span class="nv">return_value</span><span class="o">=</span><span class="nv">$?</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$return_value</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span>
<span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>The script behaves similarly as the one-liner, but the script has one more line: it starts with &#8220;#!/bin/bash&#8221;. This is also called shebang, a character sequence at the beginning of a script indicating which tool should be used to interpret the script (in this case bash).</p>
<p>You can store the above in a file, and then execute it by passing it to bash explicitly:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ bash ./test.sh
found
</pre></div>
</div>
<p>Or you can simply make it executable, in which case it can be directly interpreted using bash:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ chmod +x test.sh
$ ./test.sh
</pre></div>
</div>
<p>(The command &#8220;chmod&#8221; modifies the access rights to a file, and passing it &#8220;+x&#8221; means the file is allowed to be executed.)</p>
</div>
</div>
<div class="section" id="process-handling">
<h2>2.1.5. Process handling<a class="headerlink" href="#process-handling" title="Permalink to this headline">Â¶</a></h2>
<p>Process handling refers to managing how and when programs (processes) start and end.</p>
<p>Typically, unless overridden by the program, hitting ctrl+c sends SIGTERM (signal to terminate) to the current program. SIGTERM is a signal that tells a program it should terminate, and by default will kill the program. However programs are allowed to install a <em>signal handler</em> for SIGTERM so they can perform any necessary cleanup before terminating, for example closing and saving any files that have been modified.</p>
<p>Another useful key combination is ctrl+z which stops the program execution and puts it in the background. This means that you can start a process, for example &#8220;less test.txt&#8221;, then exit the program but keep it running by pressing ctrl+z which will drop you back to the shell. Let&#8217;s go through an example usage:</p>
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ cp -i big_file.tgz /mnt
^Z
<span class="o">[</span><span class="m">1</span><span class="o">]</span>+  Stopped                 cp -i big_file.tgz /mnt
$ <span class="nb">bg</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span>+ cp -i big_file.tgz /mnt <span class="p">&amp;</span>
$ ls
Makefile  dep.rst   ex_js2.rst
$
<span class="o">[</span><span class="m">1</span><span class="o">]</span>+  Done                    cp -i big_file.tgz /mnt
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s assume we have a very large file we want to copy somewhere. Copying large files can take time, and cp by default doesn&#8217;t output anything while copying. We start the copy on line 1.</p>
<p>After waiting for some time, we get bored and want to do something else so we press ctrl+z. This is shown in the terminal with ^Z (line 2). Pressing this key combination will tell us that the copy command has been stopped (line 3), and drops us back in our shell (line 4).</p>
<p>We then issue the command &#8220;bg&#8221; which means the previous command should run in the <em>background</em>, meaning it can run but should not prevent us from using the shell. Issuing this command tells us on line 5 that the copy command continues to run again, pointed out by the &amp; sign at the end of the command.</p>
<p>On line 6 we can then do what we want, e.g. run &#8220;ls&#8221;.</p>
<p>On line 7, we have the prompt again and wait for some time, until we expect the copy command to have finished. We can check if this is indeed the case by hitting enter (doing nothing). Bash uses this opportunity to tell us that the copy operation indeed has finished (line 9).</p>
<p>If you&#8217;re running a command and you want to start it on the background right away, you can add the &amp; sign to the end of the command:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cp -i big_file.tgz /mnt <span class="p">&amp;</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span> <span class="m">23904</span>
$
</pre></div>
</div>
<p>If you have a command running in the background but want to run it on the foreground again, run &#8220;fg&#8221;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cp -i big_file.tgz /mnt <span class="p">&amp;</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span> <span class="m">23904</span>
$ <span class="nb">fg</span>
cp -i big_file.tgz /mnt
$
</pre></div>
</div>
<p>If you want to see which commands you have running in the background in the current terminal, run &#8220;ps&#8221;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ ps
  PID TTY          TIME CMD
 <span class="m">5898</span> pts/8    <span class="m">00</span>:00:01 bash
<span class="m">23904</span> pts/8    <span class="m">00</span>:00:00 cp
<span class="m">23905</span> pts/8    <span class="m">00</span>:00:00 ps
</pre></div>
</div>
<p>If you want to send a SIGTERM signal to another process than what&#8217;s currently running in the foreground, you can use the &#8220;kill&#8221; command with the PID (process ID) of the process you want to kill, for example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$Â cp -i big_file.tgz /mnt <span class="p">&amp;</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span> <span class="m">23904</span>
$Â ps
  PID TTY          TIME CMD
 <span class="m">5898</span> pts/8    <span class="m">00</span>:00:01 bash
<span class="m">23904</span> pts/8    <span class="m">00</span>:00:00 cp
<span class="m">23905</span> pts/8    <span class="m">00</span>:00:00 ps
$ <span class="nb">kill</span> <span class="m">23904</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span>+  Terminated              cp -i big_file.tgz /mnt
$
</pre></div>
</div>
<p>Note that bash tells you the PID of the newly started process when you start it on the background using &amp;.</p>
<p>Because a program can install a signal handler for SIGTERM, it&#8217;s possible that sending SIGTERM to a program won&#8217;t kill it. To force kill a program you need to send the signal SIGKILL (signal 9 as can be seen from the signal man page at &#8220;man 7 signal&#8221;):</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cp -i big_file.tgz /mnt <span class="p">&amp;</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span> <span class="m">23937</span>
$ <span class="nb">kill</span> -9 <span class="m">23937</span>
$
<span class="o">[</span><span class="m">1</span><span class="o">]</span>+  Killed                  cp -i big_file.tgz /mnt
$
</pre></div>
</div>
<p><em>Exercise</em>: Start &#8220;less&#8221; to browse a file, hit ctrl+z to move it to the background, then run &#8220;fg&#8221; to bring it to foreground again.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.1. Basic Unix shell scripting</a><ul>
<li><a class="reference internal" href="#unix-pipelines">2.1.1. Unix pipelines</a></li>
<li><a class="reference internal" href="#further-unix-shell-tips-and-tricks">2.1.2. Further Unix shell tips and tricks</a><ul>
<li><a class="reference internal" href="#man">2.1.2.1. man</a></li>
<li><a class="reference internal" href="#sort">2.1.2.2. sort</a></li>
<li><a class="reference internal" href="#variables">2.1.2.3. Variables</a></li>
<li><a class="reference internal" href="#echo-and-cat">2.1.2.4. echo and cat</a></li>
<li><a class="reference internal" href="#exit-codes">2.1.2.5. Exit codes</a></li>
<li><a class="reference internal" href="#multiple-commands">2.1.2.6. Multiple commands</a></li>
<li><a class="reference internal" href="#globbing">2.1.2.7. Globbing</a></li>
<li><a class="reference internal" href="#seq">2.1.2.8. Seq</a></li>
<li><a class="reference internal" href="#find">2.1.2.9. Find</a></li>
</ul>
</li>
<li><a class="reference internal" href="#redirecting">2.1.3. Redirecting</a></li>
<li><a class="reference internal" href="#shell-scripts">2.1.4. Shell scripts</a><ul>
<li><a class="reference internal" href="#simple-for-loops">2.1.4.1. simple for loops</a></li>
<li><a class="reference internal" href="#if-and-branches">2.1.4.2. if and branches</a></li>
<li><a class="reference internal" href="#storing-scripts-in-a-file">2.1.4.3. Storing scripts in a file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#process-handling">2.1.5. Process handling</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="unix_index.html">2. Unix shell</a><ul>
      <li>Previous: <a href="unix_index.html" title="previous chapter">2. Unix shell</a></li>
      <li>Next: <a href="vcs.html" title="next chapter">2.2. Version control</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/unix.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Antti Salonen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/unix.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>