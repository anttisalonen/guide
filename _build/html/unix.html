<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Basic Unix shell commands &#8212; guide 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Regular expressions" href="regex.html" />
    <link rel="prev" title="Generating input data using Python" href="python_generate_file.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="basic-unix-shell-commands">
<h1>Basic Unix shell commands<a class="headerlink" href="#basic-unix-shell-commands" title="Permalink to this headline">¶</a></h1>
<p>Basic Unix shell commands are quite useful in day to day software development.</p>
<p>Let&#8217;s assume you have the file with 10,000 lines defining the functions as discussed in &#8220;Generating input data using Python&#8221;. In order to inspect this file, you could open it in the text editor, but there are also other, typically easier, ways to achieve this.</p>
<p>In the following, the character &#8216;$&#8217; means the shell prompt, i.e. you typically type in the shell whatever comes after &#8216;$&#8217;.</p>
<p>If you wanted to take a quick look browsing a file, you could use the utility &#8216;less&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ less test.txt
</pre></div>
</div>
<p>This will open the file test.txt in &#8216;less&#8217;, which allows you to read and browse the file. Less has a few useful commands:</p>
<ul class="simple">
<li>&#8216;q&#8217; exists less</li>
<li>&#8216;/&#8217; allows you to search in the file - type &#8216;/&#8217; followed by the string you want to search for, followed by &#8216;return&#8217;</li>
<li>&#8216;n&#8217; repeats the previous search</li>
<li>&#8216;N&#8217; repeats the previous search but searches backwards</li>
</ul>
<p>There are a few more, and you can look up the reference for &#8216;less&#8217; to see all of them (by running &#8220;man less&#8221;). These same commands are to some degree shared across several other Unix tools. For example vim has the same commands for searching.</p>
<p>Let&#8217;s say you only wanted to see the beginning of the file. You can achieve this using &#8216;head&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ head test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">1</span>.980206 -3.655827 -2.629755
-8.687820 -6.930905 -8.731439
-0.608791 -8.126272 -8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>This will print the first ten lines of the file. You can adjust the number of lines output by using the &#8220;-n&#8221; switch. For example, the command &#8220;head -n5 test.txt&#8221; would only output the first five lines.</p>
<p>The command &#8216;tail&#8217; can be used to output the last lines of a file, by default ten:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ tail test.txt
<span class="o">[</span>...<span class="o">]</span>
-7.058864 -5.461025 -8.337095
-0.197971 -1.485949 -0.748672
-3.051099 -9.215679 <span class="m">3</span>.597125
<span class="m">0</span>.868340 -2.444818 -3.173135
</pre></div>
</div>
<p>If you want to search for a string in the file, you can use &#8216;grep&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ grep <span class="s2">&quot;1234&quot;</span> test.txt
<span class="m">6</span>.133025 -4.612349 <span class="m">4</span>.969612
-0.904910 -5.976920 <span class="m">8</span>.821234
-6.123416 <span class="m">7</span>.494195 <span class="m">4</span>.350390
-1.123468 <span class="m">0</span>.327963 <span class="m">1</span>.291879
</pre></div>
</div>
<p>This command would print all lines which have the string &#8220;1234&#8221; in them. The command &#8216;grep&#8217; also has a lot of useful switches, for example including lines before or after the line that includes the search string, or inverse search (only print lines that don&#8217;t have a match).</p>
<p>If you only wanted to print one column of the file, you could achieve this using &#8216;awk&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt
<span class="m">7</span>.269553
<span class="m">1</span>.980206
-8.687820
-0.608791
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>This example only prints the first column in the file. (&#8216;awk&#8217; by default assumed the space is the delimiter character.)</p>
<p>&#8216;awk&#8217; is actually a programming language capable of much more, but much of the daily use is simple one-liners. Let&#8217;s say we want to calculate the average of all values in the first column. This can be achieved using &#8216;awk&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{sum += $1; n++} END {print sum / n}&#39;</span> test.txt
<span class="m">0</span>.0478027
</pre></div>
</div>
<p>What this line means is:</p>
<ul class="simple">
<li>For each line, take the value of the number in the first column, and add it in the variable called &#8220;sum&#8221; (automatically initialised to 0). Increment the variable &#8220;n&#8221; by one (also automatically initialised to 0).</li>
<li>After the file has been processed, print &#8220;sum&#8221; divided by &#8220;n&#8221;, i.e. the sum divided by the number of lines.</li>
</ul>
<p>Another useful command is &#8216;wc&#8217;, or &#8220;word count&#8221;, which can be used to count the words in a file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ wc test.txt
<span class="m">10000</span>  <span class="m">30000</span> <span class="m">284890</span> test.txt
</pre></div>
</div>
<p>The output includes the number of lines, words, characters and the file name. By adding the switch &#8216;-l&#8217;, only the number of lines and the file name are output:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ wc -l test.txt
<span class="m">10000</span> test.txt
</pre></div>
</div>
<p>The final command introduced here is &#8216;sed&#8217;, or &#8220;stream editor&#8221;, which modified the input using a given expression. For example we can use &#8216;sed&#8217; to change all space characters in the file to commas:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sed <span class="s1">&#39;s/ /,/g&#39;</span> test.txt
<span class="m">7</span>.269553,3.427526,6.633603
<span class="m">1</span>.980206,-3.655827,-2.629755
-8.687820,-6.930905,-8.731439
-0.608791,-8.126272,-8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>Let&#8217;s break down this expression &#8216;s/ /,/g&#8217;:</p>
<ul class="simple">
<li>The character &#8216;/&#8217; is the delimiter; the expression consists of four parts: &#8216;s&#8217;, &#8216; &#8216;, &#8216;,&#8217; and &#8216;g&#8217;:</li>
<li>&#8216;s&#8217;: initial command: search (and replace)</li>
<li>&#8216; &#8216;: search for the space character</li>
<li>&#8216;,&#8217;: replace with the comma</li>
<li>&#8216;g&#8217;: do this globally, i.e. not only once per line (the default), but for all occurrences in the file.</li>
</ul>
<p>Another example is removing all &#8216;-&#8216; characters from the file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sed <span class="s1">&#39;s/-//g&#39;</span> test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">1</span>.980206 <span class="m">3</span>.655827 <span class="m">2</span>.629755
<span class="m">8</span>.687820 <span class="m">6</span>.930905 <span class="m">8</span>.731439
<span class="m">0</span>.608791 <span class="m">8</span>.126272 <span class="m">8</span>.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>We can also pass multiple expressions to &#8216;sed&#8217; by using the &#8216;-e&#8217; switch, for example to replace spaces with commas and remove the dashes:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sed -e <span class="s1">&#39;s/ /,/g&#39;</span> -e <span class="s1">&#39;s/-//g&#39;</span> test.txt
<span class="m">7</span>.269553,3.427526,6.633603
<span class="m">1</span>.980206,3.655827,2.629755
<span class="m">8</span>.687820,6.930905,8.731439
<span class="m">0</span>.608791,8.126272,8.652504
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<div class="section" id="unix-pipelines">
<h2>Unix pipelines<a class="headerlink" href="#unix-pipelines" title="Permalink to this headline">¶</a></h2>
<p>The &#8216;awk&#8217; command above lists the first column for all 10,000 lines which might not be what you want. Let&#8217;s say you only wanted to see the first ten lines, i.e. apply the &#8216;head&#8217; command to the output of the &#8216;awk&#8217; command. You can achieve this using pipelines:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt <span class="p">|</span> head
<span class="m">7</span>.269553
<span class="m">1</span>.980206
-8.687820
-0.608791
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>In this case, head doesn&#8217;t take a file name as input, but instead reads from standard input, i.e. the output from &#8216;awk&#8217;. This is the typical behaviour for Unix commands.</p>
<p>In general, the commands can be combined in any way, giving a lot of power to the user.</p>
<p><em>Exercise</em>: Find out how many lines in the file have no &#8216;-&#8216; character.</p>
</div>
<div class="section" id="further-unix-shell-tips-and-tricks">
<h2>Further Unix shell tips and tricks<a class="headerlink" href="#further-unix-shell-tips-and-tricks" title="Permalink to this headline">¶</a></h2>
<div class="section" id="man">
<h3>man<a class="headerlink" href="#man" title="Permalink to this headline">¶</a></h3>
<p>The command &#8220;man&#8221; (short for &#8220;manual&#8221;) allows you to browse the documentation of different tools. For example, running &#8220;man grep&#8221; will display the documentation for grep. The documentation is opened using &#8220;less&#8221;, such that you can browse the text freely and exit with &#8216;q&#8217;.</p>
</div>
<div class="section" id="sort">
<h3>sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h3>
<p>The tool &#8220;sort&#8221; sorts its input line by line. By default it sorts alphabetically, but by passing the switch &#8220;-n&#8221; it will interpret its input data numerically. It by default sorts based on the beginning of each line but this can be changed:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sort -n test.txt <span class="p">|</span> head
-9.995596 <span class="m">8</span>.887278 <span class="m">2</span>.325502
-9.995454 -0.339710 <span class="m">4</span>.518171
-9.993047 -9.059912 -0.660508
-9.990530 -5.503126 -8.374026
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>(If your sort command output seems nonsensical, it might be due to the locale set on your shell such that the decimal point is defined as &#8216;,&#8217; instead of &#8216;.&#8217;, confusing sort. You should be able to fix this by running &#8220;export LC_ALL=C&#8221;.)</p>
<p>The above sorted the data based on the first column. If we wanted to sort by the second column instead, we can use:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ sort -n -k <span class="m">2</span> test.txt <span class="p">|</span> head
<span class="m">0</span>.649875 -9.998834 <span class="m">2</span>.834749
-3.819303 -9.998413 -7.295722
<span class="m">0</span>.985071 -9.997176 <span class="m">1</span>.182082
-6.991833 -9.995815 -7.523136
</pre></div>
</div>
<p>&#8220;sort&#8221; also allows redefining the delimiter character using the &#8220;-t&#8221; switch. For more information, run &#8220;man sort&#8221;.</p>
</div>
<div class="section" id="variables">
<h3>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h3>
<p>Variable support is typically something that Unix shells have built in. That is, defining variables isn&#8217;t executing a program per se, but rather using a feature of the shell itself.</p>
<p>Terminology wise, there are different Unix shells (called for example bash, tcsh, zsh), each with different characteristics and quirks, but each one typically implements the same core functionality, namely being compatible with the original Unix shell (sh) and conforming to the POSIX shell specification.</p>
<p>This example defines a variable in bash:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nv">MY_FILE</span><span class="o">=</span>test.txt
$ head -n1 <span class="nv">$MY_FILE</span>
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
</pre></div>
</div>
<p>In other words, defining a variable is trivial, and you can use the variable by prefixing it with a dollar sign.</p>
<p>Sometimes you might want to combine the variable with other bits. In those cases it&#8217;s typically safe to enclose the variable with curly brackets ({ and }). This will make it clear when the variable name starts and ends. For example, if we wanted to combine two variables in one file name:</p>
<blockquote>
<div>$ MY_FILE_START=test
$ MY_FILE_SUFFIX=txt
$ echo ${MY_FILE_START}.${MY_FILE_SUFFIX}
test.txt</div></blockquote>
</div>
<div class="section" id="echo-and-cat">
<h3>echo and cat<a class="headerlink" href="#echo-and-cat" title="Permalink to this headline">¶</a></h3>
<p>The command &#8220;echo&#8221; simply prints its output. For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s2">&quot;hello&quot;</span>
hello
$ <span class="nb">echo</span> <span class="nv">$MY_FILE</span>
test.txt
</pre></div>
</div>
<p>The command &#8220;cat&#8221; concatenates files. It can also be used to display the contents of a file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cat test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">1</span>.980206 -3.655827 -2.629755
-8.687820 -6.930905 -8.731439
-0.608791 -8.126272 -8.652504
</pre></div>
</div>
</div>
<div class="section" id="exit-codes">
<h3>Exit codes<a class="headerlink" href="#exit-codes" title="Permalink to this headline">¶</a></h3>
<p>Whenever you&#8217;ve finished running a program in Unix, it will return an exit code. The convention is that the exit code 0 means success while non-0 means failure. You can typically see the conditions under which a program returns success or failure by looking at the documentation. For example, grep returns exit code 1 if the search string was not found at all. You can use the special built-in variable $? to access the exit code:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ grep <span class="m">2345</span> test.txt
<span class="m">5</span>.145898 <span class="m">3</span>.219212 <span class="m">3</span>.234599
<span class="m">3</span>.323714 <span class="m">3</span>.883829 -4.722345
<span class="m">6</span>.142345 -4.611688 <span class="m">0</span>.817618
-7.761082 <span class="m">9</span>.886385 -5.742345
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>
$ grep <span class="m">23456</span> test.txt
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-commands">
<h3>Multiple commands<a class="headerlink" href="#multiple-commands" title="Permalink to this headline">¶</a></h3>
<p>You can run multiple commands in series in one line. The following runs &#8220;head&#8221;, followed by &#8220;tail&#8221;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ head -n <span class="m">1</span> test.txt <span class="p">;</span> tail -n <span class="m">1</span> test.txt
<span class="m">7</span>.269553 <span class="m">3</span>.427526 <span class="m">6</span>.633603
<span class="m">0</span>.868340 -2.444818 -3.173135
</pre></div>
</div>
<p>You can also run multiple commands depending on the exit code of the previous execution. The shorthand &#8220;&amp;&amp;&#8221; means &#8220;run the following command only if the previous command succeeded, i.e. returned an exit code 0&#8221;. The shorthand &#8220;||&#8221; means &#8220;run the following command only if the previous command failed&#8221;. You can also group commands using parentheses. For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="o">(</span>grep <span class="m">2345</span> test.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span><span class="o">)</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span>
<span class="m">5</span>.145898 <span class="m">3</span>.219212 <span class="m">3</span>.234599
<span class="m">3</span>.323714 <span class="m">3</span>.883829 -4.722345
<span class="m">6</span>.142345 -4.611688 <span class="m">0</span>.817618
-7.761082 <span class="m">9</span>.886385 -5.742345
found
$ <span class="o">(</span>grep <span class="m">23456</span> test.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span><span class="o">)</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span>
not found
</pre></div>
</div>
</div>
<div class="section" id="globbing">
<h3>globbing<a class="headerlink" href="#globbing" title="Permalink to this headline">¶</a></h3>
<p>Globbing refers to using special characters to match multiple files. An example is &#8220;*.py&#8221; which means &#8220;all files with the extension .py in the current directory&#8221;. For example, to find out the number of lines in Python files:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ wc -l *.py
 <span class="m">156</span> conf.py
   <span class="m">8</span> gen.py
   <span class="m">4</span> rand.py
   <span class="m">3</span> with.py
 <span class="m">171</span> total
</pre></div>
</div>
</div>
<div class="section" id="seq">
<h3>seq<a class="headerlink" href="#seq" title="Permalink to this headline">¶</a></h3>
<p>The command &#8220;seq&#8221; simply outputs a sequence of numbers:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ seq <span class="m">1</span> <span class="m">5</span>
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
</pre></div>
</div>
<p>This might not be very useful by itself but can be handy when combined with other tools.</p>
</div>
</div>
<div class="section" id="redirecting">
<h2>Redirecting<a class="headerlink" href="#redirecting" title="Permalink to this headline">¶</a></h2>
<p>You can always write the output of a command to a file by redirecting, i.e. using the &#8216;&gt;&#8217; character:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt &gt; output.txt
</pre></div>
</div>
<p>This will create a file called output.txt, overwriting any previous contents, with the output of the &#8216;awk&#8217; command.</p>
<p>You can also append to the end of an existing file, by using &#8216;&gt;&gt;&#8217;:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ awk <span class="s1">&#39;{print $1}&#39;</span> test.txt &gt;&gt; output.txt
</pre></div>
</div>
<p>Redirecting will allow us to simplify writing our own software. For example, it might not be necessary to open a file for writing in Python, so instead of this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>...we can simply do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">print</span> <span class="s2">&quot;</span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="mf">0.5</span>
</pre></div>
</div>
<p>...and then run it like this:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ python with.py &gt; test.txt
</pre></div>
</div>
<p>This has the added flexibility that we haven&#8217;t hard coded the output file name.</p>
<p>If necessary, you can also discard the output by redirecting it to the special file /dev/null, which has the sole purpose of consuming and discarding all its input:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ python with.py &gt; /dev/null
</pre></div>
</div>
<p><em>Exercise</em>: rewrite your program that generates the 10,000 functions file to write to standard output.</p>
</div>
<div class="section" id="shell-scripts">
<h2>Shell scripts<a class="headerlink" href="#shell-scripts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="simple-for-loops">
<h3>simple for loops<a class="headerlink" href="#simple-for-loops" title="Permalink to this headline">¶</a></h3>
<p>In most Unix shells including bash you can define for loops. For example, let&#8217;s say you wanted to run your number generation program three times, and store the output to different files:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="k">for</span> i in <span class="m">1</span> <span class="m">2</span> <span class="m">3</span><span class="p">;</span> <span class="k">do</span> python gen.py &gt; functions_<span class="si">${</span><span class="nv">i</span><span class="si">}</span>.txt <span class="p">;</span> <span class="k">done</span>
</pre></div>
</div>
<p>This will generate three files named functions_1.txt, functions_2.txt and functions_3.txt.</p>
<p>If we wanted to generate a hundred files, typing in the number would get tedious. We can use &#8220;seq&#8221; instead:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> <span class="m">100</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span> python gen.py &gt; functions_<span class="si">${</span><span class="nv">i</span><span class="si">}</span>.txt <span class="p">;</span> <span class="k">done</span>
</pre></div>
</div>
<p>This will generate a hundred files. The notation $(...) allows capturing the output of a command within another command.</p>
</div>
<div class="section" id="if-and-branches">
<h3>if and branches<a class="headerlink" href="#if-and-branches" title="Permalink to this headline">¶</a></h3>
<p>The shell built-in command &#8220;if&#8221; allows branching. There are other built-ins for comparing values against each other. For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ grep -q <span class="m">2345</span> test.txt <span class="p">;</span> <span class="nv">return_value</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="nv">$return_value</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span><span class="p">;</span> <span class="k">else</span> <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span><span class="p">;</span> <span class="k">fi</span>
</pre></div>
</div>
<p>This command will output &#8220;found&#8221; if the string was found in the input file, and &#8220;not found&#8221; otherwise. (The &#8220;-q&#8221; switch to grep suppresses output.)</p>
</div>
<div class="section" id="storing-scripts-in-a-file">
<h3>Storing scripts in a file<a class="headerlink" href="#storing-scripts-in-a-file" title="Permalink to this headline">¶</a></h3>
<p>It&#8217;s often practical to store scripts to a file. Here&#8217;s the previous example stored in a file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

grep -q <span class="m">2345</span> test.txt
<span class="nv">return_value</span><span class="o">=</span><span class="nv">$?</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$return_value</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;found&quot;</span>
<span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;not found&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>The script behaves similarly as the one-liner, but the script has one more line: it starts with &#8220;#!/bin/bash&#8221;. This is also called shebang, a character sequence at the beginning of a script indicating which tool should be used to interpret the script (in this case bash).</p>
<p>You can store the above in a file, and then execute it by passing it to bash explicitly:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ bash ./test.sh
found
</pre></div>
</div>
<p>Or you can simply make it executable, in which case it can be directly interpreted using bash:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ chmod +x test.sh
$ ./test.sh
</pre></div>
</div>
<p>(The command &#8220;chmod&#8221; modifies the access rights to a file, and passing it &#8220;+x&#8221; means the file is allowed to be executed.)</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic Unix shell commands</a><ul>
<li><a class="reference internal" href="#unix-pipelines">Unix pipelines</a></li>
<li><a class="reference internal" href="#further-unix-shell-tips-and-tricks">Further Unix shell tips and tricks</a><ul>
<li><a class="reference internal" href="#man">man</a></li>
<li><a class="reference internal" href="#sort">sort</a></li>
<li><a class="reference internal" href="#variables">Variables</a></li>
<li><a class="reference internal" href="#echo-and-cat">echo and cat</a></li>
<li><a class="reference internal" href="#exit-codes">Exit codes</a></li>
<li><a class="reference internal" href="#multiple-commands">Multiple commands</a></li>
<li><a class="reference internal" href="#globbing">globbing</a></li>
<li><a class="reference internal" href="#seq">seq</a></li>
</ul>
</li>
<li><a class="reference internal" href="#redirecting">Redirecting</a></li>
<li><a class="reference internal" href="#shell-scripts">Shell scripts</a><ul>
<li><a class="reference internal" href="#simple-for-loops">simple for loops</a></li>
<li><a class="reference internal" href="#if-and-branches">if and branches</a></li>
<li><a class="reference internal" href="#storing-scripts-in-a-file">Storing scripts in a file</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="python_generate_file.html" title="previous chapter">Generating input data using Python</a></li>
      <li>Next: <a href="regex.html" title="next chapter">Regular expressions</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/unix.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Antti Salonen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/unix.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>