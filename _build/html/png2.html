

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3.2.2. Finishing our simple PNG parser &#8212; Software Development: A Pragmatic Approach 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3.3. Strongly, statically typed languages" href="strong_index.html" />
    <link rel="prev" title="3.2.1. PNG files" href="png.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="strong_index.html" title="3.3. Strongly, statically typed languages"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="png.html" title="3.2.1. PNG files"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Software Development: A Pragmatic Approach 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch3_index.html" >3. Stage 1.5</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="bin_index.html" accesskey="U">3.2. Working with binary data</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2.2. Finishing our simple PNG parser</a><ul>
<li><a class="reference internal" href="#data-driven-programming">3.2.2.1. Data driven programming</a></li>
<li><a class="reference internal" href="#typedefs">3.2.2.2. Typedefs</a></li>
<li><a class="reference internal" href="#parsing-the-chunks">3.2.2.3. Parsing the chunks</a><ul>
<li><a class="reference internal" href="#slight-digression-switch-case">3.2.2.3.1. Slight digression: switch-case</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="png.html"
                        title="previous chapter">3.2.1. PNG files</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="strong_index.html"
                        title="next chapter">3.3. Strongly, statically typed languages</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/png2.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finishing-our-simple-png-parser">
<h1>3.2.2. Finishing our simple PNG parser<a class="headerlink" href="#finishing-our-simple-png-parser" title="Permalink to this headline">¶</a></h1>
<p>We&#8217;re now able to do some preliminary parsing of a PNG file, but we&#8217;re still lacking the parsing of the actual blocks.</p>
<p>We won&#8217;t parse all blocks - most notably, we won&#8217;t parse the actual image data - but we can get some information out of some of the other blocks. For example, the header block (IHDR), the background colour block (bKGD) and last modification block (tIME) give us some good cases for practising our programming skills. For such blocks, we can set the goal of simply printing out the contents to stdout.</p>
<div class="section" id="data-driven-programming">
<h2>3.2.2.1. Data driven programming<a class="headerlink" href="#data-driven-programming" title="Permalink to this headline">¶</a></h2>
<p>Now, we have code to tell when we&#8217;ve stumbled upon a block, we know how long a block is in bytes, and we know where to find the contents of the block. What we could do is simply check the type of the block and then have some logic to react to it, i.e.:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;chunk: %s - len: %d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chunkbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">12</span><span class="p">));</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chunkbuf</span><span class="p">,</span> <span class="s">&quot;IHDR&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Image width: ...&quot;</span><span class="p">);</span>
    <span class="cm">/* more printfs */</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chunkbuf</span><span class="p">,</span> <span class="s">&quot;tIME&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Year: ...&quot;</span><span class="p">);</span>
    <span class="cm">/* more printfs */</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(...)</span> <span class="cm">/* and so on */</span>
</pre></div>
</div>
<p>However, this is an excellent use case to simplify the logic (i.e. reduce the number of if&#8217;s) and try <em>data driven programming</em>, where we capture the different functionality in <em>tables</em>, or arrays with an ID and a function pointer designating what to do.</p>
<p>What we want to have is the following:</p>
<ol class="arabic simple">
<li>We&#8217;ll have one function for each type of chunk</li>
<li>We&#8217;ll create an array of structs, whereby each struct has a string (const char pointer) which is the type of the chunk, and a function pointer pointing to the function that handles the chunk</li>
<li>We&#8217;ll have a for loop looping through this array instead of the if-else if chain, calling the relevant function for each found block</li>
</ol>
<p>Let&#8217;s illustrate this.</p>
</div>
<div class="section" id="typedefs">
<h2>3.2.2.2. Typedefs<a class="headerlink" href="#typedefs" title="Permalink to this headline">¶</a></h2>
<p>First of all, when working with function pointers in C, it&#8217;s often practical to define the type of the function in a <em>typedef</em>. This is mainly because the syntax of declaring function pointers in C can be seen as a bit complex, and with a typedef we can capture this complexity in one place. What typedef does is simply assign another name to a type. In our case, our type is a function pointer.</p>
<p>We want a separate function for each type of chunk, and our typedef should describe the type for such a function. Our function should return nothing (void), and it should take a const pointer to an input buffer plus its length as parameters. Here&#8217;s an example declaration of such a function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">time_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>A typedef for function pointers that could point to such functions would be:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler_ptr</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, when we want to have a variable which points to a function, we can use &#8220;handler_ptr&#8221; as the type for that variable. In fact, let&#8217;s do just that, and declare such a variable as part of a struct:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">handler</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="n">handler_ptr</span> <span class="n">func</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have a struct with a const char pointer and a function pointer.</p>
<p>Now we can define a global variable which is an array of such structs. While generally global variables aren&#8217;t great, our array will be constant and as such not lead to confusing code even though it&#8217;s global:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="k">struct</span> <span class="n">handler</span> <span class="n">handlers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="s">&quot;IHDR&quot;</span><span class="p">,</span> <span class="n">header_handler</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">&quot;tIME&quot;</span><span class="p">,</span> <span class="n">time_handler</span> <span class="p">},</span>
    <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>   <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have an array of total three structs, such that the const char pointer identifies the type of the chunk and the second variable in the struct refers to a function to call for that chunk. We have the last value only contain NULL pointers to mark the end of the array which will be useful soon.</p>
<p>We can now define each function - they can be empty for now:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">header_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* repeat for time_handler */</span>
</pre></div>
</div>
<p>Finally, we can add the loop in our main function to call each function:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">chunkbuf</span><span class="p">,</span> <span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">func</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s go through this line by line:</p>
<ul class="simple">
<li>Line 1: We loop through our array. The terminating condition checks for NULL value for the type: if the type pointer is NULL, we know we&#8217;ve reached the end of the array and terminate the loop. This is a convention we&#8217;ve agreed to by ourselves.</li>
<li>Line 2: We check if the current element in the array matches the chunk type we&#8217;ve found in the file.</li>
<li>Line 3: We call the function pointer pointed to by the struct in the array, and pass it the data from the file.</li>
<li>Line 4: As we&#8217;ve found the correct handler and called it, we can terminate the loop.</li>
</ul>
<p><em>Exercise</em>: Put all of the above together. Your handlers don&#8217;t need to do anything with the data yet but your code will need to compile.</p>
</div>
<div class="section" id="parsing-the-chunks">
<h2>3.2.2.3. Parsing the chunks<a class="headerlink" href="#parsing-the-chunks" title="Permalink to this headline">¶</a></h2>
<p>We can now implement our first chunk handler - the handler for the header. We simply need to validate the input to ensure we&#8217;re not reading past the end of the buffer, then call &#8220;printf&#8221; for the relevant data as per the file format specification. The chunk handler can start like this:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">header_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">validate</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">13</span><span class="p">,</span> <span class="s">&quot;header must be 13 bytes&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Width:              %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">get_big_endian</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Height:             %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">get_big_endian</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Bit depth:          %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><em>Exercise</em>: Finish the header handler. Look up from the spec what the contents of the header are expected to be.</p>
<p>We can then proceed to the time handler (type &#8220;tIME&#8221;). If you check the spec you&#8217;ll see that it has a field with two bytes. If it was one, we could simply cast to unsigned char. If it was four, we could use our &#8220;get_big_endian&#8221; function. Since it&#8217;s two, we need another function to parse it correctly.</p>
<p><em>Exercise</em>: Implement the time handler. Read in the year using a function &#8220;get_2_byte_big_endian&#8221; which you need to define yourself. It should work the same as &#8220;get_big_endian&#8221; but only read in two bytes.</p>
<p><em>Exercise</em>: Add another handler to handle the &#8220;pHYs&#8221; block. Look up from the spec what the format is.</p>
<p>Finally, for this chapter, we&#8217;ll need to implement the background colour handler. This is interesting because, if you look at the spec, you&#8217;ll see that how to parse it depends on the colour type which was defined in the header. This means that we&#8217;ll have to store the colour type in a variable in the header handler and have it accessible for the background colour handler.</p>
<p>While we could in theory use a global variable for this, such generally leads to confusing code, and we can do better. A nice way to go about this is to add another parameter to the handler functions which is shared among all functions. Generally it&#8217;s best to define a struct for all the data you need to thread through the functions, e.g.:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">png_data</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">color_type</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now, we need to change the function pointer typedef to include a pointer to &#8220;struct png_data&#8221;, and add this parameter to all the handler functions. We can then define a variable of this type in main, clear its memory, and pass a pointer to it to the handler function being called.</p>
<p>Once we have this, we can set the &#8220;color_type&#8221; variable in the header handler, and read its value in the background colour handler. (As we&#8217;ll pass a pointer to the struct to the functions, we can access it with the -&gt; syntax, e.g. png-&gt;color_type.)</p>
<p><em>Exercise</em>: Add the background colour handler function to your program. Depending on the file, it should print either the palette index, grey colour value or the red, green and blue background colour values.</p>
<div class="section" id="slight-digression-switch-case">
<h3>3.2.2.3.1. Slight digression: switch-case<a class="headerlink" href="#slight-digression-switch-case" title="Permalink to this headline">¶</a></h3>
<p>You may have implemented the background colour handler using something like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">png</span><span class="o">-&gt;</span><span class="n">color_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">png</span><span class="o">-&gt;</span><span class="n">color_type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">png</span><span class="o">-&gt;</span><span class="n">color_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="p">...</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;unknown color type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, but C provides another way to implement this kind of a pattern, namely the <em>switch-case</em> syntax. The above could be translated to switch-case like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">switch</span><span class="p">(</span><span class="n">png</span><span class="o">-&gt;</span><span class="n">color_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
        <span class="cm">/* code here */</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
        <span class="cm">/* code here */</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="cm">/* more cases here */</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Unknown background color type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In other words, we can define the points to jump to depending on the input variable value. We&#8217;ll need to add break statements at the end of each case as otherwise the execution would continue to the next case. The &#8220;default&#8221; case is jumped to if no other case matched.</p>
<p><em>Exercise</em>: Rewrite your background colour handler to use switch-case.</p>
<p>One thing we didn&#8217;t discuss here was checking the CRC to ensure the data hasn&#8217;t been corrupted. However, RFC 2083 includes C code to calculate the CRC which we can reuse.</p>
<p><em>Exercise</em>: Copy the code from RFC 2083 to your program. Using the sample code, calculate the CRC of each block and compare it to the CRC stored in the file (they should match). Note that the CRC needs to be calculated over the data field <em>and</em> the chunk type field. You may need to make some modifications to the sample code to account for const and different signs.</p>
<p>After these exercises, for the sample image, the output should be something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">chunk</span><span class="p">:</span> <span class="n">IHDR</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">13</span> <span class="p">(</span><span class="mi">15154</span><span class="p">)</span>
<span class="n">Width</span><span class="p">:</span>              <span class="mi">732</span>
<span class="n">Height</span><span class="p">:</span>             <span class="mi">150</span>
<span class="n">Bit</span> <span class="n">depth</span><span class="p">:</span>          <span class="mi">8</span>
<span class="n">Color</span> <span class="nb">type</span><span class="p">:</span>         <span class="mi">6</span>
<span class="n">Compression</span> <span class="n">method</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">Filter</span> <span class="n">method</span><span class="p">:</span>      <span class="mi">0</span>
<span class="n">Interlace</span> <span class="n">method</span><span class="p">:</span>   <span class="mi">0</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">bKGD</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">6</span> <span class="p">(</span><span class="mi">15136</span><span class="p">)</span>
<span class="n">R</span><span class="p">:</span> <span class="mi">255</span>
<span class="n">G</span><span class="p">:</span> <span class="mi">255</span>
<span class="n">B</span><span class="p">:</span> <span class="mi">255</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">pHYs</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">9</span> <span class="p">(</span><span class="mi">15115</span><span class="p">)</span>
<span class="n">pixels</span><span class="o">/</span><span class="n">unit</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2835</span>
<span class="n">pixels</span><span class="o">/</span><span class="n">unit</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2835</span>
<span class="n">unit</span><span class="p">:</span>           <span class="mi">1</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">tIME</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">7</span> <span class="p">(</span><span class="mi">15096</span><span class="p">)</span>
<span class="n">Year</span><span class="p">:</span>   <span class="mi">2018</span>
<span class="n">Month</span><span class="p">:</span>  <span class="mi">2</span>
<span class="n">Day</span><span class="p">:</span>    <span class="mi">4</span>
<span class="n">Hour</span><span class="p">:</span>   <span class="mi">22</span>
<span class="n">Minute</span><span class="p">:</span> <span class="mi">44</span>
<span class="n">Second</span><span class="p">:</span> <span class="mi">30</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">iTXt</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">29</span> <span class="p">(</span><span class="mi">15055</span><span class="p">)</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">IDAT</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">8192</span> <span class="p">(</span><span class="mi">6851</span><span class="p">)</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">IDAT</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">6827</span> <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">chunk</span><span class="p">:</span> <span class="n">IEND</span> <span class="o">-</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">CRC</span> <span class="n">correct</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Congratulations, you now have your own simple (partial) PNG file parser.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="strong_index.html" title="3.3. Strongly, statically typed languages"
             >next</a> |</li>
        <li class="right" >
          <a href="png.html" title="3.2.1. PNG files"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Software Development: A Pragmatic Approach 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch3_index.html" >3. Stage 1.5</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="bin_index.html" >3.2. Working with binary data</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Antti Salonen.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>