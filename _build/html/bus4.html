<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>17.10. Monolithic way - merging and putting it all together &#8212; guide 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="18. A fistful of Python exercises" href="py4_index.html" />
    <link rel="prev" title="17.9. Monolithic way - scheduled arrivals and GPS data" href="bus3.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="monolithic-way-merging-and-putting-it-all-together">
<h1>17.10. Monolithic way - merging and putting it all together<a class="headerlink" href="#monolithic-way-merging-and-putting-it-all-together" title="Permalink to this headline">¶</a></h1>
<p>We now have the logic to create incoming bus data from GPS as well as from the schedules. Let&#8217;s merge these to the final output that will be shown on the display.</p>
<p>Like in Python, our merging logic could work e.g. the following way:</p>
<ul class="simple">
<li>Combine the two arrays (vectors) to one</li>
<li>Find out which buses (route number/start number combinations) have already passed, and for which buses GPS data exists</li>
<li>From our array, filter out the entries which originate from the schedule where we either have the GPS arrival data or know they have already passed</li>
<li>Sort the final array</li>
</ul>
<p>The output data format can be the same as the input data format, i.e. data that tells the route number, assumed arrival time and the kind (scheduled or estimated from GPS data) for each bus. Once we have this data we can create the labels required for the display.</p>
<p>Here are some hints to help you get started:</p>
<ul>
<li><p class="first">You can append one vector at the end of another by using the following code: vec1.insert(vec1.end(), vec2.begin(), vec2.end());</p>
<blockquote>
<div><ul class="simple">
<li>The first parameter tells the std::vector::insert() member function where to start appending. The second and third parameters tell from where to where to append.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">In Python we used sets to take note which buses have already passed or we have GPS arrival data on. We can do the same in C++ but as the amount of data is relatively small it should be no problem to use std::vectors for holding this data. Similarly to Python, tuples can be used to identify the buses. You&#8217;ll need to note both the route number and start number. In other words, the type for the data could be e.g. std::vector&lt;std::tuple&lt;int, int&gt;&gt;.</p>
</li>
<li><p class="first">We&#8217;ve already seen how to remove (filter) elements from a vector. Finding an element in a vector to use in a predicate can be done like this:</p>
</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
       <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">route_nr</span><span class="p">,</span> <span class="n">start_nr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</pre></div>
</div>
<p>This code searches the vector &#8220;vec&#8221; for a tuple which has the values &#8220;route_nr&#8221; and &#8220;start_nr&#8221;. std::find returns vec.end() if the element was not found. Hence, e.g. the following code would remove all elements from a vector &#8220;vec1&#8221; that are included in another vector &#8220;vec2&#8221;:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">bi</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">vec2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">bi</span><span class="p">.</span><span class="n">route_nr</span><span class="p">,</span> <span class="n">bi</span><span class="p">.</span><span class="n">start_nr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">vec2</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
        <span class="p">});</span>
</pre></div>
</div>
<p><em>Exercise</em>: Implement the merge function and test it.</p>
<div class="section" id="parsing-a-timestamp">
<h2>17.10.1. Parsing a timestamp<a class="headerlink" href="#parsing-a-timestamp" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;re starting to have a decent program but it&#8217;s not yet parsing the command line options (unless you already added it). One question when implementing the command line parsing might be about parsing a timestamp in format &#8220;hh:mm&#8221;. We need to split this string by the &#8221;:&#8221; character, similarly to s.split(&#8216;:&#8217;) in Python. This can be done in C++ e.g. using the following code:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">time</span><span class="p">;</span>
<span class="c1">// FIXME: set time to hold a string in &quot;hh:mm&quot; format here</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">t</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Could not parse time&quot;</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ind</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</pre></div>
</td></tr></table></div>
<p>Going this line by line:</p>
<ul class="simple">
<li>Line 3: We convert time from char* to an std::string</li>
<li>Line 4: Find the index of the character &#8216;:&#8217;. std::string::find will return std::string::npos if the character was not found.</li>
<li>Line 7: We find the <em>substring</em> within t that holds the hour. The function std::string::substr(a, b) will return a string that includes characters from a to b (a inclusive, b exclusive).</li>
<li>Line 7: We then convert the string to an int using the built-in function std::stoi (string to int).</li>
<li>Line 8: We repeat this for minutes, but pass only one parameter to std::string::substr. This causes the function to return all characters from the given index until the end.</li>
</ul>
<p><em>Exercise</em>: Look up the reference for the function std::string::substr.</p>
<p><em>Exercise</em>: Add command line argument parsing to your code. It should receive the current timestamp in &#8220;hh:mm&#8221; format, the name of the bus stop to display, and three file names for the schedule data, historical and current GPS data respectively. Check the value of argc to ensure you&#8217;re receiving the correct number of parameters. Exit with an error message and a return value of 1 otherwise.</p>
</div>
<div class="section" id="displaying-the-labels">
<h2>17.10.2. Displaying the labels<a class="headerlink" href="#displaying-the-labels" title="Permalink to this headline">¶</a></h2>
<p>As part of our chapters around SDL we put together a program that will display the labels as required, and take a filename as input which must contain the labels to be displayed. While we could generate such a file in our C++ program and then call that program, the cleaner way seems to be to call the existing code directly.</p>
<p>What we need to do for this is:</p>
<ul class="simple">
<li>Refactor the existing code to allow our class that previously took the file name in the constructor and then read in the contents to have another constructor which takes an std::array&lt;std::string, 23&gt; as a parameter instead and uses the contents of that array directly</li>
<li>Instantiate an object of that class in our C++ program, putting together and passing it an std::array&lt;std::string, 23&gt;</li>
<li>Calling the relevant member function or functions of that object such that the correct visual output is generated</li>
</ul>
<p>Now, in order to use both our existing SDL code and our new C++ code together, you have a couple of options:</p>
<ul class="simple">
<li>Copy-paste all the existing SDL code to our new .cpp file</li>
<li>Expose the existing SDL code in a <em>header file</em>, #include that header file in our new .cpp file, and compile and link the two .cpp files to one program</li>
</ul>
<p>As the first one introduces duplicate code we&#8217;ll go with the second option.</p>
<div class="section" id="header-files">
<h3>17.10.2.1. Header files<a class="headerlink" href="#header-files" title="Permalink to this headline">¶</a></h3>
<p>A header file in C and C++ typically describes the interface of the functionality implemented in the corresponding .cpp file. This means that it shouldn&#8217;t have any function definitions but it should declare the functions that are defined in the .c or .cpp file and define the data structures (including classes) that may be used from other files.</p>
<p>In our case, our header for exposing the SDL functionality could look like this:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;SDL.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;SDL_ttf.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">SDL_Schedule</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">SDL_Schedule</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">23</span><span class="o">&gt;&amp;</span> <span class="n">labels</span><span class="p">);</span>
        <span class="n">SDL_Schedule</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">fn</span><span class="p">);</span>
        <span class="o">~</span><span class="n">SDL_Schedule</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">display</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">init</span><span class="p">();</span>

        <span class="n">TTF_Font</span><span class="o">*</span> <span class="n">m_font</span><span class="p">;</span>
        <span class="n">SDL_Window</span><span class="o">*</span> <span class="n">m_screen</span><span class="p">;</span>
        <span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">m_renderer</span><span class="p">;</span>
        <span class="n">SDL_Color</span> <span class="n">m_col_white</span><span class="p">;</span>
        <span class="n">SDL_Color</span> <span class="n">m_col_yellow</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_labels_filename</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s see what we have.</p>
<ul class="simple">
<li>Line 1: We include a <em>header guard</em> which ensures the header file will only be compiled once per compilation unit (typically a .cpp file, plus any headers that were #included). Without &#8220;#pragma once&#8221;, if one were to #include this header file more than once, either directly or indirectly, we&#8217;d have declared the class multiple times, leading to compile errors. Another way to define a header guard is to use e.g. &#8220;#ifndef MY_HEADER_H&#8221; followed by &#8220;#define MY_HEADER_H&#8221; at the top of the header file and &#8220;#endif&#8221; at the end of the header file. These are a commonly used way to say &#8220;if this random string hasn&#8217;t yet been defined, define it, then define the rest of the header, end if&#8221;, i.e. &#8220;only include this file once&#8221;.</li>
<li>Lines 3-7: We #include the header files that are required for our class definition.</li>
<li>Lines 9ff: We actually define our class. We don&#8217;t define any member functions here but only include the definition of the class. The logic is that function definitions can only be defined once per executable program but the data type needs to be visible to any compilation unit that defines variables of that data type.</li>
</ul>
<p>We should end up with e.g. have the following structure:</p>
<ul class="simple">
<li>sdl.cpp - this includes the member function definitions of the class SDL_Schedule. It #includes sdl.h. It must not include a main function. If it does then comment it out, or move it to another file.</li>
<li>sdl.h - this has the SDL_Schedule class definition as per above.</li>
<li>bus.cpp - this has our other logic, and most importantly, the main function. It #includes sdl.h and defines and uses a variable of type SDL_Schedule.</li>
</ul>
<p>Now, generally in C and C++, source files are compiled to object files (binary files including the machine code instructions that were generated from the input C code), and one or multiple object files can be linked to an executable. When you run e.g.:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ g++ -o hello hello.cpp
</pre></div>
</div>
<p>...what the compiler actually does is implicitly convert all the intermediate steps to one. To explicitly compile an object file and link it to an executable, you&#8217;d do:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ g++ -c -o hello.o hello.cpp
$ ld -o hello hello.o
</pre></div>
</div>
<p>Here, we first instruct the compiler to generate an object file with -c, then call the linker (ld) and pass it the object file as input, asking it to create the final executable. (Instead of calling ld, depending on the C++ compiler, one could also call the C++ compiler directly, e.g. g++, which would invoke the linker.)</p>
<p>Now, when we have two .cpp files, we have two options:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ g++ -o hello file1.cpp file2.cpp
</pre></div>
</div>
<p>Here, we pass the compiler two .cpp files to compile to a single executable. The compiler compiles each file separately, and finally invokes the linker to link them.</p>
<p>Alternatively we can use:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ g++ -c -o file1.o file1.cpp
$ g++ -c -o file2.o file2.cpp
$ ld -o hello file1.o file2.o
</pre></div>
</div>
<p>Here, we explicitly compile each .cpp file to an object file and finally tell the linker to link all of them to an executable. The good thing about this method is that is improves the time it takes to compile our program; the former will always compile each .cpp file while with the latter, you can skip compiling the .cpp files that haven&#8217;t been changed since the last compilation. Makefile rules come in handy here.</p>
<div class="topic">
<p class="topic-title first">#include &lt;header&gt; or #include &#8220;header&#8221;?</p>
<p>We&#8217;ve seen two ways to include headers: either using the angled brackets or quotes. The difference is in the path the C++ compiler uses to find the header file; for angled brackets, it searches in the system directories which are dependent on the compiler and typically include the libraries installed on the system while the quoted brackets mean the compiler first searches in the local directory before going to the system directories. Typically you should use quotes for the header files in the project you&#8217;re currently working on, and angled brackets for libraries that aren&#8217;t included in your current project. SDL2 recommends a bit different approach and suggests the user should always use quotes for including SDL2 headers.</p>
<p>Furthermore, you can specify more directories to search for headers when invoking the compiler. The switch -I followed by a path adds the given path to the list of directories to use when searching for headers. E.g. the SDL2 command sdl2-config &#8211;cflags, which we use during compilation, could include e.g. the string &#8220;-I/usr/include/SDL2&#8221; when expanded, meaning the compiler should look for the headers in that directory.</p>
</div>
<p>Compiling and linking our program becomes more interesting when external libraries like SDL2 are used. To make it short, when compiling, the compiler needs to know where to find the header files. When linking, the compiler needs to know where to find the library files. In case of SDL2, we could e.g. use the following:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ g++ -Wall -I/usr/include/SDL2 -c -o file1.o file1.cpp
$ g++ -Wall -I/usr/include/SDL2 -c -o file2.o file2.cpp
$ ld -L/usr/lib -lSDL2 -lSDL2_ttf -o hello file1.o file2.o
</pre></div>
</div>
<p>Here, we pass the include path to the compiler while compiling using the -I switch, such that the compiler will be able to find the SDL2 header files.</p>
<p>After compilation, we pass the linker the path where to find libraries using the -L switch, and tell it which libraries to link using the -l switch (in this case, SDL2 and SDL2_ttf).</p>
<p>SDL2 provides us with the helper tool sdl2-config which can generate these for us. sdl2-config &#8211;cflags generates the correct -I line (and more) while sdl2-config &#8211;libs generates the switches required by the linker. This is the reason we call and expand sdl2-config we compile our code that uses SDL2.</p>
<p><em>Exercise</em>: Use our SDL code from our bus logic code. Create a new header file or files as necessary. Compile and run your code. Fill out all the holes so that your code will do everything: parse the input files, generate the labels required for the display and display the labels. Create an std::map to map route numbers to names.</p>
<p>If you made it here, congratulations.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.10. Monolithic way - merging and putting it all together</a><ul>
<li><a class="reference internal" href="#parsing-a-timestamp">17.10.1. Parsing a timestamp</a></li>
<li><a class="reference internal" href="#displaying-the-labels">17.10.2. Displaying the labels</a><ul>
<li><a class="reference internal" href="#header-files">17.10.2.1. Header files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="design_index.html">17. Larger software</a><ul>
      <li>Previous: <a href="bus3.html" title="previous chapter">17.9. Monolithic way - scheduled arrivals and GPS data</a></li>
      <li>Next: <a href="py4_index.html" title="next chapter">18. A fistful of Python exercises</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/bus4.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Antti Salonen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/bus4.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>