

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4.3.1. Tech behind this book &#8212; Learn Programming 0.1</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Solutions to exercises" href="ex_index.html" />
    <link rel="prev" title="4.3. Final bits" href="close_index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ex_index.html" title="5. Solutions to exercises"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="close_index.html" title="4.3. Final bits"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Learn Programming 0.1</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch4_index.html" >4. Stage 2</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="close_index.html" accesskey="U">4.3. Final bits</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.3.1. Tech behind this book</a><ul>
<li><a class="reference internal" href="#diagrams">4.3.1.1. Diagrams</a></li>
<li><a class="reference internal" href="#miscellaneous">4.3.1.2. Miscellaneous</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="close_index.html"
                        title="previous chapter">4.3. Final bits</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ex_index.html"
                        title="next chapter">5. Solutions to exercises</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/book.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tech-behind-this-book">
<h1>4.3.1. Tech behind this book<a class="headerlink" href="#tech-behind-this-book" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the technology used for creating this book.</p>
<p>The text is written using vim, in a format called <em>reStructuredText</em> (rst). Rst is fairly simple to write and looks like this:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="gh">Title</span>
<span class="gh">-----</span>

This is some text.

<span class="p">..</span> <span class="ow">code-block</span><span class="p">::</span> <span class="k">python</span>

  <span class="k">print</span> <span class="s1">&#39;foo&#39;</span>

Here&#39;s an image.

<span class="p">..</span> <span class="ow">image</span><span class="p">::</span> ../material/foo/bar.png
</pre></div>
</div>
<p>After I’ve written a section in rst, I feed it to <em>Sphinx</em>. Sphinx is a Python tool that can generate documentation for a piece of software, but it can apparently also be used for books. It takes rst as input and can generate output in various formats such as HTML and LaTeX (which can be converted to PDF - which can be printed to a physical book). Sphinx also extends rst by defining some additional directives, for example for generating a table of contents.</p>
<p>I had Sphinx generate a Makefile for myself so after I’ve written a new section, I can run e.g.:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make html latexpdf
</pre></div>
</div>
<p>This command will generate both HTML and PDF from the input rst files which are defined in the main table of contents.</p>
<p>It’s worth going a bit more into detail on LaTeX. LaTeX (often pronounced “lah-tech” - as in “technical”) is a typesetting system which takes LaTeX files as input and outputs files such as PDF. LaTeX input files, again, look e.g. like this:</p>
<div class="highlight-latex notranslate"><div class="highlight"><pre><span></span><span class="k">\section</span><span class="nb">{</span>Javascript<span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span><span class="k">\detokenize</span><span class="nb">{</span>js<span class="nb">_</span>index:javascript<span class="nb">}}</span><span class="k">\label</span><span class="nb">{</span><span class="k">\detokenize</span><span class="nb">{</span>js<span class="nb">_</span>index::doc<span class="nb">}}</span>

<span class="k">\subsection</span><span class="nb">{</span>Guessing game in JS<span class="nb">}</span>
<span class="k">\label</span><span class="nb">{</span><span class="k">\detokenize</span><span class="nb">{</span>js:guessing-game-in-js<span class="nb">}}</span><span class="k">\label</span><span class="nb">{</span><span class="k">\detokenize</span><span class="nb">{</span>js::doc<span class="nb">}}</span>
Let’s write a guessing game. This game is fairly simple: the computer thinks of a number between 1 and 25, and you need to guess what it is. The computer will give hints such as “my number is smaller” or “my number is bigger” on wrong guesses.
</pre></div>
</div>
<p>In other words, it supports several different commands that describe what the output should be like. Sphinx generates LaTeX files from the rst input, and also generates and runs a Makefile which runs the Perl script latexmk which runs pdflatex which actually generates the PDF.</p>
<p>The following diagram displays the overall flow. The grey boxes represent applications while the white spots are data.</p>
<a class="reference internal image-reference" href="_images/rst.png"><img alt="_images/rst.png" src="_images/rst.png" style="width: 292.5px; height: 414.9px;" /></a>
<p>Apart from using Sphinx, another alternative I read about afterwards was Asciidoctor, which is software that takes files written in AsciiDoc syntax as input (which has some similarities to rst, e.g. is also plain text) and can generate various outputs such as HTML and PDF.</p>
<div class="section" id="diagrams">
<h2>4.3.1.1. Diagrams<a class="headerlink" href="#diagrams" title="Permalink to this headline">¶</a></h2>
<p>The dot format was discussed in section “Graphs”, and this book uses that format and the Graphviz tool for most of the diagrams.</p>
<p>There are a few diagrams not generated with Graphviz, though. When I needed to create some diagrams manually or needed specific symbols, like with the diagrams on electric circuits, I used draw.io which is an online diagram maker. The diagrams created using draw.io can be exported and imported as XML. Furthermore, draw.io can turn the diagrams to images such as .png files.</p>
<p>Apart from Graphviz and dot, in the chapter “Quadratic formula” I needed to generate an image of a quadratic function. For this I used a <em>Jupyter notebook</em>. Jupyter notebook is a web application that allows the user to write Python code and display the results. Because Jupyter notebooks make it easy to load, analyse and visualise data and share the results, they’re popular among people who need to work with data.</p>
<p>Within the Jupyter notebook, I used the Python libraries <em>plotly</em> and <em>numpy</em>. Plotly makes it easy to create plots within Python code, and numpy makes it easy to work with numbers in larger scale in Python, such as multi-dimensional arrays and matrices.</p>
<p>The following screenshot illustrates the Jupyter notebook used for generating the quadratic function diagram:</p>
<img alt="_images/jup.png" src="_images/jup.png" />
<p>Here, the Jupyter server is started on localhost and connected to using the browser. The code at the top is the code needed for generating the plot. The variables x0 and y0 use numpy constructs to generate arrays of the data to display: x0 is an array with values from -3 to 3 with steps of 0.1, and y0 is an array where each value depends on the corresponding element in x0 as described in the formula. Finally, the two arrays are provided to plotly for generating the diagram. Plotly supports exporting the diagram to a PNG file.</p>
</div>
<div class="section" id="miscellaneous">
<h2>4.3.1.2. Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>The screenshots, where necessary, were created using scrot. Scrot is a Unix command line tool that can create screenshots. I typically instruct it to wait for two seconds (so I can bring the relevant window to focus), then take a screenshot of the currently active window and store it as a pre-defined file name. This workflow works fairly well as it saves me from having to cut, crop or save images.</p>
<p>While generating the PDF for the print version, I noticed many of the diagrams generated using dot had too low DPI (dots per inch). I found out I can increase the DPI by passing the command line flag “-Gdpi=300” to dot, but this meant I needed to regenerate all the PNG files from the dot files. The following command took care of this for me (split to multiple lines for readability):</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">for</span> file in <span class="k">$(</span>find . -name <span class="s1">&#39;*.dot&#39;</span><span class="k">)</span>
<span class="k">do</span>
    <span class="nb">pushd</span> <span class="k">$(</span>dirname <span class="nv">$file</span><span class="k">)</span>
    dot -Tpng -Gdpi<span class="o">=</span><span class="m">300</span> <span class="k">$(</span>basename <span class="nv">$file</span><span class="k">)</span> &gt; <span class="k">$(</span>basename <span class="nv">$file</span> .dot<span class="k">)</span>.png
    <span class="nb">popd</span>
<span class="k">done</span>
</pre></div>
</td></tr></table></div>
<p>Let’s see what this does:</p>
<ul class="simple">
<li>Line 1: We find all the dot files within the current directory or any subdirectories, and loop over them</li>
<li>Line 3: We first capture the <em>directory</em> where the file resides using shell expansion (“$(…)”), and then <em>push</em> this directory to a stack. Bash supports a stack for directories such that one can push a directory in the stack, which changes the current working directory and also allows the directory to be <em>popped</em> later which changes the current working directory back to what it was before the push.</li>
<li>Line 4: We capture the <em>base name</em> of the dot file - this is the file name without the directory part. We also run “$(basename $file .dot).png” which first removes the “.dot” suffix from the file name and then adds the “.png” suffix to it. Running this dot command for e.g. a file “foo.dot” effectively runs dot on “foo.dot” to generate a “foo.png”.</li>
<li>Line 5: We pop the directory from the stack, arriving at the previous directory. Doing this allows our script (or one-liner) to end up in the directory we started in.</li>
</ul>
<p>Github provides a hosting service for hosting web pages such as the one for this book. There’s a command to publish the generated HTML on Github pages (“git subtree push –prefix _build/html/ origin gh-pages”) but as this command was difficult to remember I created a simple shell script “publish.sh” with only this command as the contents. This way, once I’ve committed a new section, I could run “git push origin master &amp;&amp; ./publish.sh” which would upload all the changes online.</p>
<p>The dependency diagrams were generated using dot. I have the master dot file which describes the actual dependencies, but this dot file doesn’t include the actual section titles, only the file names. I then wrote a simple shell script to read the section titles from the rst files and generate dot statements which cause the titles to be used as labels in the diagram. These generated dot statements, together with a dot header and the master dot file are then concatenated to the final dot file which describes the dependencies between the sections.</p>
<p>After the dependencies between sections are described in a dot file, another dot file is generated from this input which describes the dependencies between chapters (one chapter can include multiple sections). This is done in a simple Python script which parses a) the section dependencies from the dot file, and b) which sections belong to which chapters from the rst files. Finally, a shell script is run which passes the two dot files to another Python script which removes unnecessary edges (this script was written as part of the section “Parsing”) and creates the final PNG images from the dot files. This flow is run as part of the Makefile invocation.</p>
<p>The source code for the book is versioned using git and is publicly available in Github.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ex_index.html" title="5. Solutions to exercises"
             >next</a> |</li>
        <li class="right" >
          <a href="close_index.html" title="4.3. Final bits"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Learn Programming 0.1</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="ch4_index.html" >4. Stage 2</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="close_index.html" >4.3. Final bits</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Antti Salonen.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>