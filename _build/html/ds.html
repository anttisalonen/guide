<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4.2. Overview of data structures &#8212; guide 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Javascript" href="js_index.html" />
    <link rel="prev" title="4.1. O notation" href="o_not.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="overview-of-data-structures">
<h1>4.2. Overview of data structures<a class="headerlink" href="#overview-of-data-structures" title="Permalink to this headline">¶</a></h1>
<p>For reasons that will soon become apparent, it&#8217;s useful to have a basic understanding of data structures.</p>
<div class="section" id="arrays">
<h2>4.2.1. Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;ve already used <em>arrays</em> in C: Array is a data structure which contains multiple elements of data, such that each element uses the same amount of memory and they&#8217;re allocated contiguously:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">+---+---+---+</span>
<span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span>
<span class="o">+---+---+---+</span>
</pre></div>
</div>
<p>As you can possibly imagine, accessing an element in an array is fast (O(1)) because you can calculate the address of an element using the following formula:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">address</span><span class="p">(</span><span class="n">element_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">base_address</span> <span class="o">+</span> <span class="n">element_index</span> <span class="o">*</span> <span class="n">element_size</span>
</pre></div>
</div>
<p>However, if you wanted to insert an element in an array, you have to move all elements after the new element one slot to the right, making inserting a relatively complex (O(n)) operation. Similarly, were one to ask &#8220;do I have value x in the array&#8221;, one would have to traverse the whole array, making this an O(n) operation as well.</p>
<p>You can define an array in C with the following syntax (for example, an array with 5 ints):</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</pre></div>
</div>
<p>Lists in Python are technically also arrays but each elements holds a pointer to arbitrary data, such that in Python, each element in a list can be of different type.</p>
</div>
<div class="section" id="linked-lists">
<h2>4.2.2. Linked lists<a class="headerlink" href="#linked-lists" title="Permalink to this headline">¶</a></h2>
<p>Linked lists solve the problem of inserting an element in the middle. They&#8217;re constructed such that each element in a list holds the data as well as a pointer to the next cell in the list, whereby each cell is individually allocated.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">+--------+--+</span>      <span class="o">+--------+--+</span>      <span class="o">+--------+---+</span>
<span class="o">|</span> <span class="n">data</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">-+-----&gt;|</span> <span class="n">data</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">-+-----&gt;|</span> <span class="n">data</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span>
<span class="o">+--------+--+</span>      <span class="o">+--------+--+</span>      <span class="o">+--------+---+</span>
<span class="p">.</span>    <span class="o">^</span>
<span class="p">.</span>   <span class="n">Head</span>
</pre></div>
</div>
<p>The &#8220;head&#8221; pointer points to the beginning of the list. The last element will have the &#8220;next&#8221; pointer point to NULL (denoted by &#8220;x&#8221; in the diagram above), signaling the end of the list. If one were now to add an element in the list, this can be done by changing the &#8220;next&#8221; pointer of the previous cell in the list to point to the new element and the &#8220;next&#8221; pointer of the new element to the cell that was previously pointed to by the previous cell.</p>
<p>In practice, due to the overhead of allocating memory for individual cells and the performance issues caused by memory fragmentation and poor cache locality, linked lists rarely show any performance benefit over arrays.</p>
</div>
<div class="section" id="sets">
<h2>4.2.3. Sets<a class="headerlink" href="#sets" title="Permalink to this headline">¶</a></h2>
<p>A set is a data structure that can hold different values of data and efficiently answer the question whether a value is contained in the set or not. A typical way to achieve this is to implement a <em>balanced binary tree</em>, i.e. a tree structure which can be traversed top-down when doing basic operations such as looking up or inserting data.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="p">.</span>             <span class="o">-------------</span>
<span class="n">Root</span> <span class="n">node</span> <span class="o">--&gt;</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="p">.</span> <span class="o">|</span> <span class="p">.</span> <span class="o">|</span>
<span class="p">.</span>             <span class="o">------|---|--</span>
<span class="p">.</span>                   <span class="o">|</span>   <span class="o">|</span>
<span class="p">.</span>        <span class="o">-------------</span> <span class="o">-------------</span>
<span class="p">.</span>        <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span> <span class="p">.</span> <span class="o">|</span> <span class="o">|</span> <span class="mi">5</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span>
<span class="p">.</span>        <span class="o">----------|--</span> <span class="o">-------------</span>
<span class="p">.</span>                  <span class="o">|</span>
<span class="p">.</span>        <span class="o">-------------</span>
<span class="p">.</span>        <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span>
<span class="p">.</span>        <span class="o">-------------</span>
</pre></div>
</div>
<p>Here, the root node is the entry point to the tree. Each node has payload data as well as two pointers, one to the left and one to the right. The pointer to the left points to a node where the payload data is less than in the current node. The pointer to the right points to a node where the payload data is more than in the current node. In this example set we have stored number 1, 3, 4 and 5. If one were now to ask, &#8220;do we have number 3 stored in the set&#8221;, a function answering this would do the following:</p>
<ol class="arabic simple">
<li>Root node value is 4, which is more than 3, so enter the left node (as it is not NULL).</li>
<li>Our next node value is 1, which is less than 3, so enter the right node (as it is not NULL).</li>
<li>Our next node value is 3, which is the value we were looking for, so the function can return <em>true</em>.</li>
</ol>
<p>If we were to ask whether the number 6 is in the set, the function would do the following:</p>
<ol class="arabic simple">
<li>Root node value is 4, which is less than 6, so enter the right node (as it is not NULL).</li>
<li>Our next node value is 5, which is less than 6, but the right node pointer is NULL, hence the value 6 is not included, so the function must return <em>false</em>.</li>
</ol>
<p>Inserting a number is trickier but, similarly to lookup, can be performed in O(log n) time. (To support efficient insertion, a <em>self balancing binary search tree</em> such as a red-black tree is required.)</p>
<p>C doesn&#8217;t have built in support for sets (although C++ does). In Python, sets can be defined and used in the following manner:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="ow">in</span> <span class="n">my_set</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">6</span> <span class="ow">in</span> <span class="n">my_set</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="dictionaries">
<h2>4.2.4. Dictionaries<a class="headerlink" href="#dictionaries" title="Permalink to this headline">¶</a></h2>
<p>Dictionary, also called a <em>hash map</em>, is similar to a set but has a <em>value</em> associated with each <em>key</em> stored in the map, with the key playing the same role as the payload data did for sets.</p>
<p>Hence it can have a similar internal structure to a set, but with another pointer in each cell indicating the value for the key.</p>
<p>Apart from a binary search tree, another way to implement dictionaries is to use a <em>hash function</em> to hash the data, i.e. generate an index (or <em>bucket</em>) for each data point and use this index to retrieve the data. For example, if we have keys 1, 3, 4 and 5 in our dictionary, we could <em>hash</em> these to indices 0, 1, 2 and 3 of an array. Now, when the user asks for the value for the key 1, we access our array at index 0 and return the corresponding data.</p>
<p>In practice, the <em>hash function</em>, i.e. the function which generates this mapping from keys to indices, isn&#8217;t perfect (unless all keys are predefined) and there will need to be more indices in the array than keys, and two or more keys may use the same index, requiring the implementation to handle this case (<em>hash collision</em>), for example by storing a linked list for each index, with each element in the linked list corresponding to one key-value pair. These complexities lead to the worst case insertion (where all indices have to be regenerated) to have O(n) runtime. Search can also have O(n) worst case runtime in the case where all keys end up in a single index, such that the search degenerates to a search in a linked list.</p>
<p>C doesn&#8217;t have built in support for dictionaries (although C++ does). In Python, dictionaries can be defined and used in the following manner:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">my_dict</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># for get(), the last parameter is the default if the key is not found</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">my_dict</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">my_dict</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s1">&#39;not found&#39;</span>
<span class="gp">...</span>
<span class="go">not found</span>
</pre></div>
</div>
<p>(This example also demonstrates the Pythonic EAFP (&#8220;easier to ask for forgiveness than permission&#8221;) principle as well as exceptions: it&#8217;s typically cleaner code to try to access a key in a dictionary and handle the error if the key is not found than check beforehand whether the key is in a dictionary and only access it if it is.)</p>
</div>
<div class="section" id="summary">
<h2>4.2.5. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Finally, here&#8217;s a summary table of the performance of the different operations:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="31%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data type</th>
<th class="head">Access</th>
<th class="head">Insertion</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Array</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr class="row-odd"><td>Linked list</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="row-even"><td>Set</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr class="row-odd"><td>Dictionary (implemented using a binary search tree)</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr class="row-even"><td>Dictionary (implemented using hashing)</td>
<td>O(1) on average (O(n) in the worst case)</td>
<td>O(1) on average (O(n) in the worst case)</td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.2. Overview of data structures</a><ul>
<li><a class="reference internal" href="#arrays">4.2.1. Arrays</a></li>
<li><a class="reference internal" href="#linked-lists">4.2.2. Linked lists</a></li>
<li><a class="reference internal" href="#sets">4.2.3. Sets</a></li>
<li><a class="reference internal" href="#dictionaries">4.2.4. Dictionaries</a></li>
<li><a class="reference internal" href="#summary">4.2.5. Summary</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="ds_index.html">4. Data structures</a><ul>
      <li>Previous: <a href="o_not.html" title="previous chapter">4.1. O notation</a></li>
      <li>Next: <a href="js_index.html" title="next chapter">5. Javascript</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ds.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Antti Salonen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/ds.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>